<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>opentiny入门</title>
    <url>/2023/04/26/open-tiny%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><h2 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h2><p>core &gt; interceptor.ts</p>
<p>utils &gt; dom</p>
]]></content>
      <categories>
        <category>opentiny</category>
      </categories>
      <tags>
        <tag>源码学习</tag>
        <tag>组件库</tag>
        <tag>opentiny</tag>
      </tags>
  </entry>
  <entry>
    <title>axios核心源码学习</title>
    <url>/2022/07/06/axios%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学习一下 <code>axios</code> 的源码流程，版本为 1.3.0</p>
<p>axios中使用了很多的设计模式，这是十分重要的部分，这篇内容暂时没有涉及，希望后续可以进行更详细的学习和理解。</p>
<p>先代入一些问题</p>
<blockquote>
<p>1.为什么 <code>axios</code> 既可以当函数调用，也可以当对象使用，比如<code>axios(&#123;&#125;)</code>、<code>axios.get</code>。<br> 2.简述 <code>axios</code> 调用流程。<br> 3.有用过拦截器吗？原理是怎样的？<br> 4.有使用<code>axios</code>的取消功能吗？是怎么实现的？<br> 5.为什么支持浏览器中发送请求也支持<code>node</code>发送请求？</p>
</blockquote>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="入口文件"><a href="#入口文件" class="headerlink" title="入口文件"></a>入口文件</h3><p>从<code>package.json</code>中，找到入口文件<code>index.js</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;axios&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.3.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Promise based HTTP client for the browser and node.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;main&quot;</span><span class="punctuation">:</span> <span class="string">&quot;index.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>进入<code>index.js</code>，实际上是暴露了 axios 中的内容</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;./lib/axios.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const &#123;...&#125; = axios;</span></span><br><span class="line"><span class="comment">// export &#123;...&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="lib-x2F-axios-js（工厂模式）"><a href="#lib-x2F-axios-js（工厂模式）" class="headerlink" title="lib&#x2F;axios.js（工厂模式）"></a>lib&#x2F;axios.js（工厂模式）</h4><p>引入一些工具函数<code>utils</code>、<code>Axios</code>构造函数、默认配置<code>defaults</code>等。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> utils <span class="keyword">from</span> <span class="string">&#x27;./utils.js&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> bind <span class="keyword">from</span> <span class="string">&#x27;./helpers/bind.js&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Axios</span> <span class="keyword">from</span> <span class="string">&#x27;./core/Axios.js&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> mergeConfig <span class="keyword">from</span> <span class="string">&#x27;./core/mergeConfig.js&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> defaults <span class="keyword">from</span> <span class="string">&#x27;./defaults/index.js&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> formDataToJSON <span class="keyword">from</span> <span class="string">&#x27;./helpers/formDataToJSON.js&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">CanceledError</span> <span class="keyword">from</span> <span class="string">&#x27;./cancel/CanceledError.js&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">CancelToken</span> <span class="keyword">from</span> <span class="string">&#x27;./cancel/CancelToken.js&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> isCancel <span class="keyword">from</span> <span class="string">&#x27;./cancel/isCancel.js&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;<span class="variable constant_">VERSION</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;./env/data.js&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> toFormData <span class="keyword">from</span> <span class="string">&#x27;./helpers/toFormData.js&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">AxiosError</span> <span class="keyword">from</span> <span class="string">&#x27;./core/AxiosError.js&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> spread <span class="keyword">from</span> <span class="string">&#x27;./helpers/spread.js&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> isAxiosError <span class="keyword">from</span> <span class="string">&#x27;./helpers/isAxiosError.js&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">AxiosHeaders</span> <span class="keyword">from</span> <span class="string">&quot;./core/AxiosHeaders.js&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">HttpStatusCode</span> <span class="keyword">from</span> <span class="string">&#x27;./helpers/HttpStatusCode.js&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>生成实例对象<code>axios</code>、<code>axios.Axios</code>、<code>axios.create</code>等。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create an instance of Axios</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Object</span>&#125; defaultConfig The default config for the instance</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">Axios</span>&#125; A new instance of Axios</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createInstance</span>(<span class="params">defaultConfig</span>) &#123;</span><br><span class="line">  <span class="comment">// new 一个 Axios 生成实例对象</span></span><br><span class="line">  <span class="keyword">const</span> context = <span class="keyword">new</span> <span class="title class_">Axios</span>(defaultConfig);</span><br><span class="line">  <span class="comment">// bind 返回一个新的wrap函数</span></span><br><span class="line">  <span class="comment">// 调用axios实际上是调用Axios.prototype.request函数</span></span><br><span class="line">  <span class="keyword">const</span> instance = <span class="title function_">bind</span>(<span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">request</span>, context);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Copy axios.prototype to instance</span></span><br><span class="line">  <span class="comment">// 赋值Axios.prototype到实例上</span></span><br><span class="line">  <span class="comment">// axios.get / axios.post</span></span><br><span class="line">  utils.<span class="title function_">extend</span>(instance, <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>, context, &#123;<span class="attr">allOwnKeys</span>: <span class="literal">true</span>&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Copy context to instance</span></span><br><span class="line">  <span class="comment">// 复制context 到实例中</span></span><br><span class="line">  <span class="comment">// 如果是function，修改this指向</span></span><br><span class="line">  <span class="comment">// 如果是属性，直接复制给instance</span></span><br><span class="line">  <span class="comment">// 所以axios.defaults 和 axios.interceptors 可以直接使用</span></span><br><span class="line">  utils.<span class="title function_">extend</span>(instance, context, <span class="literal">null</span>, &#123;<span class="attr">allOwnKeys</span>: <span class="literal">true</span>&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Factory for creating new instances</span></span><br><span class="line">  <span class="comment">// 工厂模式 创建新的实例 用户可以自定义参数</span></span><br><span class="line">  instance.<span class="property">create</span> = <span class="keyword">function</span> <span class="title function_">create</span>(<span class="params">instanceConfig</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">createInstance</span>(<span class="title function_">mergeConfig</span>(defaultConfig, instanceConfig));</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码通过给 <code>axios</code> 对象添加属性和方法，以公开一些与 <code>axios</code> 相关的功能和实用方法。这些公开的属性和方法可以在使用 <code>axios</code> 时直接访问，提供了方便的接口和功能扩展。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create the default instance to be exported</span></span><br><span class="line"><span class="keyword">const</span> axios = <span class="title function_">createInstance</span>(defaults);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Expose Axios class to allow class inheritance</span></span><br><span class="line"><span class="comment">// 公开Axios类以支持类继承</span></span><br><span class="line">axios.<span class="property">Axios</span> = <span class="title class_">Axios</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Expose Cancel &amp; CancelToken</span></span><br><span class="line">axios.<span class="property">CanceledError</span> = <span class="title class_">CanceledError</span>;</span><br><span class="line">axios.<span class="property">CancelToken</span> = <span class="title class_">CancelToken</span>;</span><br><span class="line">axios.<span class="property">isCancel</span> = isCancel;</span><br><span class="line">axios.<span class="property">VERSION</span> = <span class="variable constant_">VERSION</span>;</span><br><span class="line">axios.<span class="property">toFormData</span> = toFormData;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Expose AxiosError class</span></span><br><span class="line">axios.<span class="property">AxiosError</span> = <span class="title class_">AxiosError</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// alias for CanceledError for backward compatibility</span></span><br><span class="line">axios.<span class="property">Cancel</span> = axios.<span class="property">CanceledError</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Expose all/spread</span></span><br><span class="line">axios.<span class="property">all</span> = <span class="keyword">function</span> <span class="title function_">all</span>(<span class="params">promises</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(promises);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">axios.<span class="property">spread</span> = spread;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Expose isAxiosError</span></span><br><span class="line">axios.<span class="property">isAxiosError</span> = isAxiosError;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Expose mergeConfig</span></span><br><span class="line">axios.<span class="property">mergeConfig</span> = mergeConfig;</span><br><span class="line"></span><br><span class="line">axios.<span class="property">AxiosHeaders</span> = <span class="title class_">AxiosHeaders</span>;</span><br><span class="line"></span><br><span class="line">axios.<span class="property">formToJSON</span> = <span class="function"><span class="params">thing</span> =&gt;</span> <span class="title function_">formDataToJSON</span>(utils.<span class="title function_">isHTMLForm</span>(thing) ? <span class="keyword">new</span> <span class="title class_">FormData</span>(thing) : thing);</span><br><span class="line"></span><br><span class="line">axios.<span class="property">HttpStatusCode</span> = <span class="title class_">HttpStatusCode</span>;</span><br><span class="line"></span><br><span class="line">axios.<span class="property">default</span> = axios;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this module should only have a default export</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> axios</span><br></pre></td></tr></table></figure>

<h4 id="lib-x2F-helpers-x2F-bind-js"><a href="#lib-x2F-helpers-x2F-bind-js" class="headerlink" title="lib&#x2F;helpers&#x2F;bind.js"></a>lib&#x2F;helpers&#x2F;bind.js</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">bind</span>(<span class="params">fn, thisArg</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">wrap</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> fn.<span class="title function_">apply</span>(thisArg, <span class="variable language_">arguments</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>create方法意味着返回Axios工厂，而不是作为一个类 AxiosInstance 的实例去调用</p>
<p> <a href="https://github.com/axios/axios/issues/4365">https://github.com/axios/axios/issues/4365</a></p>
</blockquote>
<h4 id="lib-x2F-utils-js-forEach"><a href="#lib-x2F-utils-js-forEach" class="headerlink" title="lib&#x2F;utils.js.forEach"></a>lib&#x2F;utils.js.forEach</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Iterate over an Array or an Object invoking a function for each item.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If `obj` is an Array callback will be called passing</span></span><br><span class="line"><span class="comment"> * the value, index, and complete array for each item.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If &#x27;obj&#x27; is an Object callback will be called passing</span></span><br><span class="line"><span class="comment"> * the value, key, and complete object for each property.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Object|Array</span>&#125; obj The object to iterate</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Function</span>&#125; fn The callback to invoke for each item</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Boolean</span>&#125; [allOwnKeys = false]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">any</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">forEach</span>(<span class="params">obj, fn, &#123;allOwnKeys = <span class="literal">false</span>&#125; = &#123;&#125;</span>) &#123;</span><br><span class="line">  <span class="comment">// Don&#x27;t bother if no value provided</span></span><br><span class="line">  <span class="keyword">if</span> (obj === <span class="literal">null</span> || <span class="keyword">typeof</span> obj === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> i;</span><br><span class="line">  <span class="keyword">let</span> l;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Force an array if not already something iterable</span></span><br><span class="line">  <span class="comment">// 不是对象，使用数组包裹</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">/*eslint no-param-reassign:0*/</span></span><br><span class="line">    obj = [obj];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isArray</span>(obj)) &#123;</span><br><span class="line">    <span class="comment">// Iterate over array values</span></span><br><span class="line">    <span class="comment">// 如果是数组，则循环调用fn函数</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, l = obj.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">      fn.<span class="title function_">call</span>(<span class="literal">null</span>, obj[i], i, obj);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Iterate over object keys</span></span><br><span class="line">    <span class="comment">// allOwnKeys有值：返回Obj自身所有属性</span></span><br><span class="line">    <span class="comment">// allOwnKeys不存在或为空：过滤原型链上可遍历的属性</span></span><br><span class="line">    <span class="keyword">const</span> keys = allOwnKeys ? <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(obj) : <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj);</span><br><span class="line">    <span class="keyword">const</span> len = keys.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      key = keys[i];</span><br><span class="line">      fn.<span class="title function_">call</span>(<span class="literal">null</span>, obj[key], key, obj);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码定义了一个名为<code>forEach</code>的函数，用于遍历对象或数组，并对每个元素执行指定的回调函数<code>fn</code>。</p>
<p>函数的作用是将回调函数<code>fn</code>应用于给定的对象或数组中的每个元素。它可以用于遍历对象的属性或数组的元素，并对它们执行相应的操作。</p>
<p>与 JavaScript 原生的 <code>forEach</code> 方法相比，这段代码有以下区别：</p>
<ol>
<li>对象和数组的处理：这段代码可以处理对象和数组两种类型的数据。当输入参数<code>obj</code>为对象时，会遍历对象的属性；当输入参数<code>obj</code>为数组时，会遍历数组的元素。而 JavaScript 原生的 <code>forEach</code> 方法只能用于遍历数组。</li>
<li>对象遍历的方式：对于对象的遍历，这段代码提供了两种方式。当<code>allOwnKeys</code>参数为<code>true</code>时，会返回对象自身的所有属性进行遍历；当<code>allOwnKeys</code>参数不存在或为空时，会过滤掉原型链上的可遍历属性，只遍历对象自身的属性。这样可以灵活地控制遍历对象时的属性范围。</li>
<li>回调函数的执行上下文：这段代码使用<code>fn.call(null, obj[key], key, obj)</code>来执行回调函数<code>fn</code>，将执行上下文设置为<code>null</code>。而 JavaScript 原生的 <code>forEach</code> 方法会将回调函数的执行上下文设置为当前遍历的元素。</li>
</ol>
<p>总结起来，这段代码的作用是提供了一个灵活的遍历函数<code>forEach</code>，可以用于遍历对象和数组，并对每个元素执行指定的回调函数。它可以处理对象的属性遍历，提供了灵活的遍历方式，并允许自定义回调函数的执行上下文。这些特点使得它在某些情况下比 JavaScript 原生的 <code>forEach</code> 方法更加灵活和功能强大。</p>
<h4 id="lib-x2F-utils-js-extend"><a href="#lib-x2F-utils-js-extend" class="headerlink" title="lib&#x2F;utils.js.extend"></a>lib&#x2F;utils.js.extend</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将b对象中的参数拓展至a对象中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @参数 &#123;Object&#125; a 需要拓展的对象</span></span><br><span class="line"><span class="comment"> * @参数 &#123;Object&#125; b 需要复制的对象</span></span><br><span class="line"><span class="comment"> * @参数 &#123;Object&#125; thisArg 需要绑定的函数对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @参数 &#123;Boolean&#125; [allOwnKeys] 只赋值指定的参数</span></span><br><span class="line"><span class="comment"> * @返回值 &#123;Object&#125; 返回拓展后的a</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">extend</span> = (<span class="params">a, b, thisArg, &#123;allOwnKeys&#125;= &#123;&#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="title function_">forEach</span>(b, <span class="function">(<span class="params">val, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (thisArg &amp;&amp; <span class="title function_">isFunction</span>(val)) &#123;</span><br><span class="line">      a[key] = <span class="title function_">bind</span>(val, thisArg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      a[key] = val;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, &#123;allOwnKeys&#125;);</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码通过调用 <code>forEach</code> 函数来遍历对象 <code>b</code>。对于遍历的每个属性或方法，会执行以下操作：</p>
<ol>
<li>如果指定了 <code>thisArg</code> 并且当前遍历的值是函数，则使用自定义的 <code>bind</code> 方法将函数绑定到 <code>thisArg</code> 上，并将绑定后的函数赋值给对象 <code>a</code> 的对应属性。</li>
<li>如果不满足上述条件，则直接将属性或方法赋值给对象 <code>a</code> 的对应属性。</li>
</ol>
<p>最后，返回拓展后的对象 <code>a</code>。</p>
<h3 id="核心构造函数-Axios-js"><a href="#核心构造函数-Axios-js" class="headerlink" title="核心构造函数 Axios.js"></a>核心构造函数 Axios.js</h3><h4 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">instanceConfig</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">defaults</span> = instanceConfig;</span><br><span class="line">  <span class="comment">// 请求和响应拦截器</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">interceptors</span> = &#123;</span><br><span class="line">    <span class="attr">request</span>: <span class="keyword">new</span> <span class="title class_">InterceptorManager</span>(),</span><br><span class="line">    <span class="attr">response</span>: <span class="keyword">new</span> <span class="title class_">InterceptorManager</span>()</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拦截器示例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加请求拦截器</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">config</span>) &#123;</span><br><span class="line">    <span class="comment">// 在发送请求之前做些什么</span></span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">&#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 对请求错误做些什么</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加响应拦截器</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="comment">// 2xx 范围内的状态码都会触发该函数。</span></span><br><span class="line">    <span class="comment">// 对响应数据做点什么</span></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 超出 2xx 范围的状态码都会触发该函数。</span></span><br><span class="line">    <span class="comment">// 对响应错误做点什么</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>移除拦截器，可以使用<code>eject</code>方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myInterceptor = axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;<span class="comment">/*...*/</span>&#125;);</span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">eject</span>(myInterceptor);</span><br></pre></td></tr></table></figure>

<p>自定义axios示例添加拦截器</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> instance = axios.<span class="title function_">create</span>();</span><br><span class="line">instance.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;<span class="comment">/*...*/</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>看一下源码实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import utils from &#x27;./../utils.js&#x27;</span><br><span class="line"></span><br><span class="line">class InterceptorManager &#123;</span><br><span class="line">    // 用一个数组来存储拦截器函数</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.handlers = []</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">   * 添加一个新的拦截器到栈中</span><br><span class="line">   *</span><br><span class="line">   * @参数 &#123;Function&#125; Promise.then(fulfilled)  回调函数</span><br><span class="line">   * @参数 &#123;Function&#125; Promise.reject(rejected) 回调函数</span><br><span class="line">   *</span><br><span class="line">   * @return &#123;Number&#125; 返回ID 用来移除拦截器时使用</span><br><span class="line">   *</span><br><span class="line">   */</span><br><span class="line">    use(fulfilled, rejected, options) &#123;</span><br><span class="line">        this.handlers.push(&#123;</span><br><span class="line">            fulfilled,</span><br><span class="line">            rejected,</span><br><span class="line">            // 是否同步</span><br><span class="line">            synchronous: options ? options.synchronous : false,</span><br><span class="line">            // 运行时机</span><br><span class="line">            runWhen: options ? options.runWhen : null</span><br><span class="line">        &#125;)</span><br><span class="line">        return this.handlers.length - 1</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    eject(id) &#123;</span><br><span class="line">        // 如果在handlers中找到对应的id，对应的位置置为空</span><br><span class="line">        if (this.handlers[id]) &#123;</span><br><span class="line">            this.handlers[id] = null</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 重置拦截器数组</span><br><span class="line">    clear() &#123;</span><br><span class="line">        if (this.handlers) &#123;</span><br><span class="line">            this.handlers = []</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 遍历拦截器数组，如果当前的位置为Null，则跳过，否则执行回调函数</span><br><span class="line">    forEach(fn) &#123;</span><br><span class="line">        utils.forEach(this.handlers, function forEachHandler(h) &#123;</span><br><span class="line">            if (h !== null) &#123;</span><br><span class="line">                fn(h)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default InterceptorManager</span><br></pre></td></tr></table></figure>

<p>给axios&#x2F;lib&#x2F;adapters&#x2F;xhr.js中的 <code>let request = new XMLHttpRequest()</code>打上断点，调用axios发送请求，查看一下axios发送请求的简要流程：</p>
<ol>
<li><p>发送请求</p>
</li>
<li><p>调用 <code>axios</code> 函数实际上是调用 <code>Axios.prototype.request</code> 函数，而这个函数使用 <code>bind</code> 返回的一个名为<code>wrap</code>的函数。</p>
</li>
<li><p>调用 <code>Axios.prototype.request</code></p>
</li>
<li><p>（有请求拦截器的情况下执行请求拦截器），中间会执行 <code>dispatchRequest</code>方法</p>
</li>
<li><p><code>dispatchRequest</code> 之后调用 <code>adapter (xhrAdapter)</code></p>
</li>
<li><p>最后调用 <code>Promise</code> 中的函数<code>dispatchXhrRequest</code>，（有响应拦截器的情况下最后会再调用响应拦截器）</p>
</li>
</ol>
<h4 id="request实现"><a href="#request实现" class="headerlink" title="request实现"></a>request实现</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Dispatch a request</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">String|Object</span>&#125; configOrUrl The config specific for this request (merged with this.defaults)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">?Object</span>&#125; <span class="variable">config</span></span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">Promise</span>&#125; The Promise to be fulfilled</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title function_">request</span>(<span class="params">configOrUrl, config</span>) &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 参数处理：</span></span><br><span class="line"><span class="comment">      如果 configOrUrl 是字符串，则将其作为 URL，并将 config 作为配置对象。</span></span><br><span class="line"><span class="comment">      如果 configOrUrl 不是字符串，则将其视为配置对象。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> configOrUrl === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    config = config || &#123;&#125;;</span><br><span class="line">    config.<span class="property">url</span> = configOrUrl;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    config = configOrUrl || &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将默认配置和传入的配置合并为最终的配置对象。</span></span><br><span class="line">  config = <span class="title function_">mergeConfig</span>(<span class="variable language_">this</span>.<span class="property">defaults</span>, config);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123;transitional, paramsSerializer, headers&#125; = config;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 处理过渡选项（transitional）：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      对于过渡选项中定义的选项进行验证。</span></span><br><span class="line"><span class="comment">      过渡选项允许在迁移期间启用或禁用某些功能。</span></span><br><span class="line"><span class="comment">      ...</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     处理参数序列化器（paramsSerializer）：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       如果参数序列化器是函数，则将其包装成 &#123; serialize: paramsSerializer &#125; 对象。</span></span><br><span class="line"><span class="comment">       否则，验证参数序列化器的正确性。</span></span><br><span class="line"><span class="comment">   */</span>    </span><br><span class="line">  <span class="keyword">if</span> (transitional !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    validator.<span class="title function_">assertOptions</span>(transitional, &#123;</span><br><span class="line">      <span class="attr">silentJSONParsing</span>: validators.<span class="title function_">transitional</span>(validators.<span class="property">boolean</span>),</span><br><span class="line">      <span class="attr">forcedJSONParsing</span>: validators.<span class="title function_">transitional</span>(validators.<span class="property">boolean</span>),</span><br><span class="line">      <span class="attr">clarifyTimeoutError</span>: validators.<span class="title function_">transitional</span>(validators.<span class="property">boolean</span>)</span><br><span class="line">    &#125;, <span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (paramsSerializer != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (utils.<span class="title function_">isFunction</span>(paramsSerializer)) &#123;</span><br><span class="line">      config.<span class="property">paramsSerializer</span> = &#123;</span><br><span class="line">        <span class="attr">serialize</span>: paramsSerializer</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      validator.<span class="title function_">assertOptions</span>(paramsSerializer, &#123;</span><br><span class="line">        <span class="attr">encode</span>: validators.<span class="property">function</span>,</span><br><span class="line">        <span class="attr">serialize</span>: validators.<span class="property">function</span></span><br><span class="line">      &#125;, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置请求方法（method）：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      如果配置中没有指定请求方法，则使用默认方法（通常为 &#x27;get&#x27;）</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  config.<span class="property">method</span> = (config.<span class="property">method</span> || <span class="variable language_">this</span>.<span class="property">defaults</span>.<span class="property">method</span> || <span class="string">&#x27;get&#x27;</span>).<span class="title function_">toLowerCase</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> contextHeaders;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 合并请求头（headers）：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      将默认请求头和请求方法对应的请求头进行合并。</span></span><br><span class="line"><span class="comment">      删除原始请求头中的方法对应的键。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  contextHeaders = headers &amp;&amp; utils.<span class="title function_">merge</span>(</span><br><span class="line">    headers.<span class="property">common</span>,</span><br><span class="line">    headers[config.<span class="property">method</span>]</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  contextHeaders &amp;&amp; utils.<span class="title function_">forEach</span>(</span><br><span class="line">    [<span class="string">&#x27;delete&#x27;</span>, <span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;head&#x27;</span>, <span class="string">&#x27;post&#x27;</span>, <span class="string">&#x27;put&#x27;</span>, <span class="string">&#x27;patch&#x27;</span>, <span class="string">&#x27;common&#x27;</span>],</span><br><span class="line">    <span class="function">(<span class="params">method</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">delete</span> headers[method];</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  config.<span class="property">headers</span> = <span class="title class_">AxiosHeaders</span>.<span class="title function_">concat</span>(contextHeaders, headers);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 处理请求拦截器和响应拦截器：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      根据拦截器的条件判断是否执行拦截器的逻辑。</span></span><br><span class="line"><span class="comment">      构建请求拦截器链和响应拦截器链。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">const</span> requestInterceptorChain = [];</span><br><span class="line">  <span class="keyword">let</span> synchronousRequestInterceptors = <span class="literal">true</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">forEach</span>(<span class="keyword">function</span> <span class="title function_">unshiftRequestInterceptors</span>(<span class="params">interceptor</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> interceptor.<span class="property">runWhen</span> === <span class="string">&#x27;function&#x27;</span> &amp;&amp; interceptor.<span class="title function_">runWhen</span>(config) === <span class="literal">false</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    synchronousRequestInterceptors = synchronousRequestInterceptors &amp;&amp; interceptor.<span class="property">synchronous</span>;</span><br><span class="line"></span><br><span class="line">    requestInterceptorChain.<span class="title function_">unshift</span>(interceptor.<span class="property">fulfilled</span>, interceptor.<span class="property">rejected</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> responseInterceptorChain = [];</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">forEach</span>(<span class="keyword">function</span> <span class="title function_">pushResponseInterceptors</span>(<span class="params">interceptor</span>) &#123;</span><br><span class="line">    responseInterceptorChain.<span class="title function_">push</span>(interceptor.<span class="property">fulfilled</span>, interceptor.<span class="property">rejected</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 发起请求：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      如果请求拦截器中有异步操作，则构建完整的拦截器链，并使用 Promise 链式调用。</span></span><br><span class="line"><span class="comment">      如果请求拦截器都是同步操作，则逐个执行请求拦截器，并更新配置对象。</span></span><br><span class="line"><span class="comment">      使用更新后的配置对象调用 dispatchRequest 函数发送请求。</span></span><br><span class="line"><span class="comment">      处理响应拦截器，并返回最终的 Promise 对象。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">let</span> promise;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> len;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!synchronousRequestInterceptors) &#123;</span><br><span class="line">    <span class="keyword">const</span> chain = [dispatchRequest.<span class="title function_">bind</span>(<span class="variable language_">this</span>), <span class="literal">undefined</span>];</span><br><span class="line">    chain.<span class="property">unshift</span>.<span class="title function_">apply</span>(chain, requestInterceptorChain);</span><br><span class="line">    chain.<span class="property">push</span>.<span class="title function_">apply</span>(chain, responseInterceptorChain);</span><br><span class="line">    len = chain.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">    promise = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(config);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">      promise = promise.<span class="title function_">then</span>(chain[i++], chain[i++]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  len = requestInterceptorChain.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> newConfig = config;</span><br><span class="line"></span><br><span class="line">  i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">    <span class="keyword">const</span> onFulfilled = requestInterceptorChain[i++];</span><br><span class="line">    <span class="keyword">const</span> onRejected = requestInterceptorChain[i++];</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      newConfig = <span class="title function_">onFulfilled</span>(newConfig);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      onRejected.<span class="title function_">call</span>(<span class="variable language_">this</span>, error);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    promise = dispatchRequest.<span class="title function_">call</span>(<span class="variable language_">this</span>, newConfig);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  i = <span class="number">0</span>;</span><br><span class="line">  len = responseInterceptorChain.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">    promise = promise.<span class="title function_">then</span>(responseInterceptorChain[i++], responseInterceptorChain[i++]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="dispatchRequest"><a href="#dispatchRequest" class="headerlink" title="dispatchRequest"></a>dispatchRequest</h4><p>这段代码主要负责调度请求的发送和处理，包括检查取消请求的情况、转换请求和响应数据、处理请求和响应的头信息，以及根据适配器发送请求并返回处理后的响应。它还处理了请求被取消和请求失败的情况，并相应地抛出 <code>CanceledError</code> 或将失败原因传递下去。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> transformData <span class="keyword">from</span> <span class="string">&#x27;./transformData.js&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> isCancel <span class="keyword">from</span> <span class="string">&#x27;../cancel/isCancel.js&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> defaults <span class="keyword">from</span> <span class="string">&#x27;../defaults/index.js&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">CanceledError</span> <span class="keyword">from</span> <span class="string">&#x27;../cancel/CanceledError.js&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">AxiosHeaders</span> <span class="keyword">from</span> <span class="string">&#x27;../core/AxiosHeaders.js&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> adapters <span class="keyword">from</span> <span class="string">&quot;../adapters/adapters.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Throws a `CanceledError` if cancellation has been requested.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Object</span>&#125; config The config that is to be used for the request</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throwIfCancellationRequested</span>(<span class="params">config</span>) &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 检查请求配置对象中是否存在 cancelToken，</span></span><br><span class="line"><span class="comment">   * 如果存在且已经发起了取消请求，则抛出 CanceledError。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (config.<span class="property">cancelToken</span>) &#123;</span><br><span class="line">    config.<span class="property">cancelToken</span>.<span class="title function_">throwIfRequested</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 检查请求配置对象中是否存在 signal，</span></span><br><span class="line"><span class="comment">   * 如果存在且请求已被中止（aborted），则抛出 CanceledError。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (config.<span class="property">signal</span> &amp;&amp; config.<span class="property">signal</span>.<span class="property">aborted</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CanceledError</span>(<span class="literal">null</span>, config);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Dispatch a request to the server using the configured adapter.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">object</span>&#125; config The config that is to be used for the request</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">Promise</span>&#125; The Promise to be fulfilled</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">dispatchRequest</span>(<span class="params">config</span>) &#123;</span><br><span class="line">  <span class="comment">// 调用 throwIfCancellationRequested(config)，检查是否需要取消请求。</span></span><br><span class="line">  <span class="title function_">throwIfCancellationRequested</span>(config);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从请求配置对象中获取请求头信息并创建 AxiosHeaders 实例。</span></span><br><span class="line">  config.<span class="property">headers</span> = <span class="title class_">AxiosHeaders</span>.<span class="title function_">from</span>(config.<span class="property">headers</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用 transformData 函数对请求数据进行转换。</span></span><br><span class="line">  config.<span class="property">data</span> = transformData.<span class="title function_">call</span>(</span><br><span class="line">    config,</span><br><span class="line">    config.<span class="property">transformRequest</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果请求方法是 &#x27;post&#x27;、&#x27;put&#x27; 或 &#x27;patch&#x27;，</span></span><br><span class="line">  <span class="comment">// 设置请求头的内容类型为 &#x27;application/x-www-form-urlencoded&#x27;。</span></span><br><span class="line">  <span class="keyword">if</span> ([<span class="string">&#x27;post&#x27;</span>, <span class="string">&#x27;put&#x27;</span>, <span class="string">&#x27;patch&#x27;</span>].<span class="title function_">indexOf</span>(config.<span class="property">method</span>) !== -<span class="number">1</span>) &#123;</span><br><span class="line">    config.<span class="property">headers</span>.<span class="title function_">setContentType</span>(<span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据请求配置对象中指定的适配器（或使用默认适配器）发送请求，并返回一个 Promise 对象。</span></span><br><span class="line">  <span class="keyword">const</span> adapter = adapters.<span class="title function_">getAdapter</span>(config.<span class="property">adapter</span> || defaults.<span class="property">adapter</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">adapter</span>(config).<span class="title function_">then</span>(<span class="keyword">function</span> <span class="title function_">onAdapterResolution</span>(<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果请求成功，调用 throwIfCancellationRequested(config)，检查是否需要取消请求。</span></span><br><span class="line">    <span class="title function_">throwIfCancellationRequested</span>(config);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 transformData 函数对响应数据进行转换。</span></span><br><span class="line">    response.<span class="property">data</span> = transformData.<span class="title function_">call</span>(</span><br><span class="line">      config,</span><br><span class="line">      config.<span class="property">transformResponse</span>,</span><br><span class="line">      response</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从响应中获取响应头信息并创建 AxiosHeaders 实例。</span></span><br><span class="line">    response.<span class="property">headers</span> = <span class="title class_">AxiosHeaders</span>.<span class="title function_">from</span>(response.<span class="property">headers</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回处理后的响应对象。</span></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;, <span class="keyword">function</span> <span class="title function_">onAdapterRejection</span>(<span class="params">reason</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_">isCancel</span>(reason)) &#123;</span><br><span class="line">      <span class="comment">// 如果请求失败且不是由于取消引起的，</span></span><br><span class="line">      <span class="comment">// 则调用 throwIfCancellationRequested(config)，检查是否需要取消请求。</span></span><br><span class="line">      <span class="title function_">throwIfCancellationRequested</span>(config);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Transform response data</span></span><br><span class="line">      <span class="keyword">if</span> (reason &amp;&amp; reason.<span class="property">response</span>) &#123;</span><br><span class="line">        reason.<span class="property">response</span>.<span class="property">data</span> = transformData.<span class="title function_">call</span>(</span><br><span class="line">          config,</span><br><span class="line">          config.<span class="property">transformResponse</span>,</span><br><span class="line">          reason.<span class="property">response</span></span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// 如果存在失败原因（reason）且原因中包含响应信息，</span></span><br><span class="line">        <span class="comment">// 则对响应数据进行转换并创建相应的 AxiosHeaders 实例。</span></span><br><span class="line">        reason.<span class="property">response</span>.<span class="property">headers</span> = <span class="title class_">AxiosHeaders</span>.<span class="title function_">from</span>(reason.<span class="property">response</span>.<span class="property">headers</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个被拒绝的 Promise 对象，将失败原因传递下去。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(reason);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="dispatchRequest-之-transformData-转换数据"><a href="#dispatchRequest-之-transformData-转换数据" class="headerlink" title="dispatchRequest 之 transformData 转换数据"></a>dispatchRequest 之 transformData 转换数据</h5><p>这段代码用于在请求发送前或响应返回后，对数据进行一系列的转换操作。转换函数可以在配置对象中指定，用于处理请求数据或响应数据的格式、结构或其他方面的变化。每个转换函数接受原始数据、标准化的请求头和响应状态码（如果是响应数据）作为参数，并返回经过处理后的数据。在转换过程中，还会对请求头进行标准化处理。最后，返回转换后的数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> utils <span class="keyword">from</span> <span class="string">&#x27;./../utils.js&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> defaults <span class="keyword">from</span> <span class="string">&#x27;../defaults/index.js&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">AxiosHeaders</span> <span class="keyword">from</span> <span class="string">&#x27;../core/AxiosHeaders.js&#x27;</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Transform the data for a request or a response</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array|Function</span>&#125; fns A single function or Array of functions</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">?Object</span>&#125; response The response object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">*</span>&#125; The resulting transformed data</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">transformData</span>(<span class="params">fns, response</span>) &#123;</span><br><span class="line">  <span class="comment">// 首先，通过 this 或默认配置对象 defaults 来获取配置信息（上下文）和默认请求头。</span></span><br><span class="line">  <span class="keyword">const</span> config = <span class="variable language_">this</span> || defaults;</span><br><span class="line">  <span class="keyword">const</span> context = response || config;</span><br><span class="line">  <span class="comment">// 创建 AxiosHeaders 实例，并将上下文中的头信息传递给它，以便进行标准化处理。</span></span><br><span class="line">  <span class="keyword">const</span> headers = <span class="title class_">AxiosHeaders</span>.<span class="title function_">from</span>(context.<span class="property">headers</span>);</span><br><span class="line">  <span class="comment">// 初始化数据变量为上下文中的数据。</span></span><br><span class="line">  <span class="keyword">let</span> data = context.<span class="property">data</span>;</span><br><span class="line">  <span class="comment">// 遍历转换函数数组 fns，对数据应用每个转换函数。</span></span><br><span class="line">  utils.<span class="title function_">forEach</span>(fns, <span class="keyword">function</span> <span class="title function_">transform</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每个转换函数接受三个参数：</span></span><br><span class="line"><span class="comment">     *  数据（data）</span></span><br><span class="line"><span class="comment">     *  标准化后的请求头（headers.normalize()）</span></span><br><span class="line"><span class="comment">     *  响应状态码（如果是响应数据）。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 每个转换函数通过 call 方法将配置对象作为上下文（this）调用，</span></span><br><span class="line"><span class="comment">     * 以便在转换函数中可以访问到配置信息。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 转换函数将对数据进行处理，并返回转换后的数据。</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    data = fn.<span class="title function_">call</span>(config, data, headers.<span class="title function_">normalize</span>(), response ? response.<span class="property">status</span> : <span class="literal">undefined</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 完成所有转换后，再次调用 headers.normalize() 来确保请求头信息被正确标准化。</span></span><br><span class="line">  headers.<span class="title function_">normalize</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回转换后的数据。</span></span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="dispatchRequest-之-adapter-适配器执行部分（适配器模式）"><a href="#dispatchRequest-之-adapter-适配器执行部分（适配器模式）" class="headerlink" title="dispatchRequest 之 adapter 适配器执行部分（适配器模式）"></a>dispatchRequest 之 adapter 适配器执行部分（适配器模式）</h5><p>这段代码的作用是提供一个适配器模块，它允许根据传入的适配器名称或适配器函数数组获取相应的适配器函数，并提供了一些已知的适配器函数。通过 <code>getAdapter</code> 函数可以根据名称或数组中的顺序查找并返回匹配的适配器函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> utils <span class="keyword">from</span> <span class="string">&#x27;../utils.js&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> httpAdapter <span class="keyword">from</span> <span class="string">&#x27;./http.js&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> xhrAdapter <span class="keyword">from</span> <span class="string">&#x27;./xhr.js&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">AxiosError</span> <span class="keyword">from</span> <span class="string">&quot;../core/AxiosError.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// knownAdapters 是一个对象，其中包含了一些已知的适配器名称和对应的适配器函数。</span></span><br><span class="line"><span class="keyword">const</span> knownAdapters = &#123;</span><br><span class="line">  <span class="attr">http</span>: httpAdapter,</span><br><span class="line">  <span class="attr">xhr</span>: xhrAdapter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">utils.<span class="title function_">forEach</span>(knownAdapters, <span class="function">(<span class="params">fn, value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 对于每个适配器函数 fn，尝试</span></span><br><span class="line"><span class="comment">   * 使用 Object.defineProperty 方法</span></span><br><span class="line"><span class="comment">   * 给函数添加一个 name 属性，值为适配器名称 value。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span>(fn) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(fn, <span class="string">&#x27;name&#x27;</span>, &#123;value&#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="comment">// eslint-disable-next-line no-empty</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(fn, <span class="string">&#x27;adapterName&#x27;</span>, &#123;value&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// getAdapter 函数用于获取适配器。它接受一个适配器名称或适配器函数数组作为参数。</span></span><br><span class="line">  <span class="attr">getAdapter</span>: <span class="function">(<span class="params">adapters</span>) =&gt;</span> &#123;</span><br><span class="line">    adapters = utils.<span class="title function_">isArray</span>(adapters) ? adapters : [adapters];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123;length&#125; = adapters;</span><br><span class="line">    <span class="keyword">let</span> nameOrAdapter;</span><br><span class="line">    <span class="keyword">let</span> adapter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历适配器数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">      <span class="comment">// 如果 nameOrAdapter 是字符串，则将其转换为小写并查找对应的已知适配器函数。</span></span><br><span class="line">      nameOrAdapter = adapters[i];</span><br><span class="line">      <span class="keyword">if</span>((adapter = utils.<span class="title function_">isString</span>(nameOrAdapter) ? knownAdapters[nameOrAdapter.<span class="title function_">toLowerCase</span>()] : nameOrAdapter)) &#123;</span><br><span class="line">        <span class="comment">// 如果找到了适配器函数，则将其赋值给变量 adapter 并跳出循环。</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果没有找到适配器函数，则抛出错误。</span></span><br><span class="line">    <span class="keyword">if</span> (!adapter) &#123;</span><br><span class="line">      <span class="keyword">if</span> (adapter === <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AxiosError</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(</span><br><span class="line">        utils.<span class="title function_">hasOwnProp</span>();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//如果找到的适配器函数不是函数类型，则抛出类型错误。</span></span><br><span class="line">    <span class="keyword">if</span> (!utils.<span class="title function_">isFunction</span>(adapter)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> adapter;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// adapters 属性为一个包含已知适配器的对象，其中键为适配器名称，值为适配器函数。</span></span><br><span class="line">  <span class="attr">adapters</span>: knownAdapters</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在请求派发过程中，调用 <code>dispatchRequest</code> 函数时会使用适配器来发送请求。而这段代码提供了一种灵活的机制，根据用户的配置或默认设置，选择合适的适配器函数。</p>
<p>具体的流程如下：</p>
<ol>
<li>当调用 <code>dispatchRequest</code> 时，首先会调用 <code>throwIfCancellationRequested</code> 函数检查是否取消了请求。</li>
<li>然后，会对请求的配置进行一些处理和转换，包括设置请求头、转换请求数据等。</li>
<li>接下来，根据配置中的适配器名称或默认适配器名称，调用 <code>getAdapter</code> 函数获取适配器函数。</li>
<li>使用适配器函数来发送请求，返回一个 Promise。</li>
<li>在 Promise 的解析函数中，再次检查是否取消了请求。</li>
<li>然后，对响应进行一些处理和转换，包括转换响应数据、设置响应头等。</li>
<li>最后，返回处理后的响应数据。</li>
</ol>
<p>这段代码的作用是提供了一个可配置的适配器机制，使 Axios 能够根据用户的配置和环境选择合适的适配器函数来发送请求，并在请求和响应的过程中进行一些处理和转换。</p>
<p>例如，在浏览器端的代码中，我们可以这样配置 Axios 使用浏览器适配器：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"></span><br><span class="line">axios.<span class="property">defaults</span>.<span class="property">adapter</span> = <span class="string">&#x27;xhr&#x27;</span>;</span><br><span class="line"></span><br><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;/api/data&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 处理响应数据</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 处理错误</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>而在服务器端的代码中，我们可以这样配置 Axios 使用 Node.js 适配器：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> axios = <span class="built_in">require</span>(<span class="string">&#x27;axios&#x27;</span>);</span><br><span class="line"></span><br><span class="line">axios.<span class="property">defaults</span>.<span class="property">adapter</span> = <span class="string">&#x27;http&#x27;</span>;</span><br><span class="line"></span><br><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;/api/data&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 处理响应数据</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 处理错误</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>通过适配器的使用，我们可以在不同的环境中统一使用 Axios 发送请求，而不需要关心底层的实现细节和平台差异，提高了开发的便利性和可维护性。</p>
<h4 id="取消请求"><a href="#取消请求" class="headerlink" title="取消请求"></a>取消请求</h4><p>在 Axios 中，取消请求指的是提前中止正在进行的网络请求，以避免不必要的响应返回和处理。当我们发送一个请求后，有时候可能会遇到以下情况：</p>
<ol>
<li>请求已经发出，但我们不再需要该请求的响应数据。</li>
<li>请求还未发出，但我们希望在某个时刻取消该请求。</li>
</ol>
<p>这时，取消请求的机制可以帮助我们有效管理请求的生命周期。</p>
<p>Axios 提供了一个 CancelToken 的机制，用于实现请求的取消。我们可以通过创建一个 CancelToken 实例，并将其传递给请求的配置对象中的 <code>cancelToken</code> 字段。当我们想要取消请求时，调用 CancelToken 实例的 <code>cancel</code> 方法，即可中止正在进行的请求。</p>
<p>具体的流程如下：</p>
<ol>
<li><p>创建 CancelToken 实例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cancelTokenSource = axios.<span class="property">CancelToken</span>.<span class="title function_">source</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p>将 CancelToken 实例传递给请求的配置对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;/api/data&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">cancelToken</span>: cancelTokenSource.<span class="property">token</span></span><br><span class="line">&#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 处理响应数据</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (axios.<span class="title function_">isCancel</span>(error)) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求被取消:&#x27;</span>, error.<span class="property">message</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求出错:&#x27;</span>, error.<span class="property">message</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>当需要取消请求时，调用 CancelToken 实例的 <code>cancel</code> 方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cancelTokenSource.<span class="title function_">cancel</span>(<span class="string">&#x27;请求取消的原因&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>取消请求的时机可以是任意的，可以在请求发出前或请求发出后进行取消。当请求被取消时，Promise 的状态将变为 rejected，并且捕获到的错误对象将具有一个 <code>isCancel</code> 属性，用于判断错误是否是由于请求被取消而产生的。</p>
<p>需要注意的是，取消请求只能在使用 CancelToken 机制的情况下生效。如果请求的配置中没有提供 <code>cancelToken</code> 字段，或者提供的 <code>cancelToken</code> 对象已经被取消过，那么取消请求的操作将不会生效。</p>
<h5 id="AbortController"><a href="#AbortController" class="headerlink" title="AbortController"></a>AbortController</h5><p>自 Axios 版本0.21.0起，<code>cancelToken</code> 被标记为弃用。Axios官方建议使用原生的AbortController来实现请求的取消。</p>
<p>原生的AbortController是浏览器提供的API，可以用于取消正在进行的请求。它与AbortSignal一起使用，可以实现请求的取消机制。</p>
<p>以下是使用AbortController取消请求的示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeconst controller = new AbortController();</span><br><span class="line"></span><br><span class="line">axios.get(&#x27;/api/data&#x27;, &#123;</span><br><span class="line">  signal: controller.signal</span><br><span class="line">&#125;)</span><br><span class="line">  .then(response =&gt; &#123;</span><br><span class="line">    // 处理响应数据</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(error =&gt; &#123;</span><br><span class="line">    if (error.name === &#x27;AbortError&#x27;) &#123;</span><br><span class="line">      console.log(&#x27;请求被取消:&#x27;, error.message);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      console.log(&#x27;请求出错:&#x27;, error.message);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">// 当需要取消请求时，调用 AbortController 的 abort() 方法</span><br><span class="line">controller.abort();</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们创建了一个AbortController实例，并将其信号（signal）传递给请求的配置对象中的 <code>signal</code> 字段。当我们调用AbortController的abort()方法时，请求将被取消，并且会抛出一个AbortError错误，我们可以通过捕获该错误来处理取消请求的情况。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们分析了<code>axios</code>的核心流程，可以知道以下几点：</p>
<ul>
<li>拦截器是怎么实现链式调用并分别加载到合适的位置中</li>
<li>自定义的适配器怎么通过配置加入到<code>axios</code>中</li>
<li><code>axios</code>怎么实现取消功能</li>
<li>request中是怎么去收集和处理拦截器的</li>
</ul>
<blockquote>
<p>​        但是axios的精髓在于他已经迭代了40个版本，但是大版本号使用为0. npm的version规则是首个版本号变化表示api不向下兼容。<br>​         而axios增加了这么多功能。却始终保持没有api明显变化。这里axios内部使用了多种设计模式和架构模式。但是文章并没有提及。提及的只是代码是干嘛的。实现了什么功能。</p>
<p>​         包括适配器，桥接，代理，抽象工厂，微内核设计。还有一些设计原则，axios里面都用的非常好。所以，你在用任何版本的axios除了一些bug以外，没有什么兼容问题</p>
</blockquote>
<p><strong>为什么 <code>axios</code> 既可以当函数调用，也可以当对象使用？</strong></p>
<blockquote>
<p>这是因为 Axios 实现了一种混合的设计模式，既是一个函数，又是一个对象。</p>
<p>当作为函数调用时，<code>axios</code> 实际上是 <code>createInstance</code> 函数的一个实例，它提供了发送请求的功能。这意味着我们可以直接使用 <code>axios(config)</code> 或 <code>axios(url, config)</code> 的形式来发送请求，类似于调用一个函数。在内部，它会创建一个 Axios 实例，并调用该实例的 <code>request</code> 方法来发送请求。</p>
<p>当作为对象使用时，<code>axios</code> 提供了一些附加的属性和方法，使我们可以对其进行配置和拓展。例如，我们可以通过 <code>axios.defaults</code> 来设置默认的请求配置，或者通过 <code>axios.interceptors</code> 来添加请求和响应拦截器。此外，还可以直接使用 <code>axios.get</code>、<code>axios.post</code> 等方法发送特定类型的请求，这些方法在内部会调用 Axios 实例的对应方法。</p>
<p>通过这种设计，我们既可以像函数一样简单地发送请求，又可以利用对象的特性对其进行更加灵活的配置和拓展。这种混合的设计模式为开发者提供了方便且可扩展的 API，使其更容易使用和定制 Axios。</p>
</blockquote>
<p><strong>简述 <code>axios</code> 调用流程。</strong></p>
<blockquote>
<ol>
<li>创建实例：通过调用 <code>axios.create()</code> 或直接调用 <code>axios</code> 函数，创建一个 <code>axios</code> 实例。这个实例既可以作为函数调用，也可以作为对象使用。</li>
<li>设置请求配置：使用实例提供的方法（例如 <code>axios.get()</code>）或直接调用实例本身（例如 <code>axios()</code>）来设置请求的 URL、方法、参数、头部等配置。</li>
<li>请求拦截器：在发送请求之前，请求会经过一系列的请求拦截器。这些拦截器可以在请求发送之前对请求进行修改、添加公共头部、处理认证等操作。拦截器可以通过 <code>axios.interceptors.request.use()</code> 方法进行添加。</li>
<li>发送请求：根据配置发送请求。<code>axios</code> 使用底层的适配器（如 <code>xhrAdapter</code>、<code>httpAdapter</code>）来发送请求，具体的适配器根据运行环境自动选择。发送请求的过程是异步的，返回一个 Promise 对象用于处理请求的结果。</li>
<li>响应拦截器：在接收到响应后，响应会经过一系列的响应拦截器。这些拦截器可以对响应进行处理、转换数据格式、统一处理错误等操作。拦截器可以通过 <code>axios.interceptors.response.use()</code> 方法进行添加。</li>
<li>处理响应：根据响应的状态码和配置进行处理。根据配置的 <code>transformResponse</code> 函数对响应数据进行转换和处理。</li>
<li>返回结果：将处理后的响应数据作为 Promise 的结果返回给调用方。可以通过 <code>.then()</code>、<code>.catch()</code> 等方法处理异步结果。</li>
</ol>
</blockquote>
<p><strong>有用过拦截器吗？原理是怎样的？</strong></p>
<blockquote>
<ul>
<li>拦截器通过<code>axios.interceptors.request.use</code>来添加请求拦截器和响应拦截器函数，先用两个数组分别收集请求拦截器和响应拦截器，然后在内部循环分别添加到两端。</li>
<li>如果需要移除拦截器，可以使用<code>eject</code>方法移除</li>
</ul>
</blockquote>
<p><strong>有使用<code>axios</code>的取消功能吗？是怎么实现的？</strong></p>
<blockquote>
<p><code>axios</code>的取消功能通过<code>config</code>配置<code>cancelToken(弃用)</code>或者<code>signal</code>来控制，如果传入了<code>cancelToken(弃用)</code>或者<code>signal</code>，则抛出异常，使流程走到<code>Promise.rejected</code></p>
</blockquote>
<p><strong>为什么支持浏览器中发送请求也支持<code>node</code>发送请求？</strong></p>
<blockquote>
<p><code>axios</code>内部默认支持<code>http</code>，<code>xhr</code>请求的适配器，可以根据当前的环境去适配不同的请求，也可以自定义适配器来满足更多的场景需求。</p>
</blockquote>
]]></content>
      <categories>
        <category>axios</category>
      </categories>
      <tags>
        <tag>axios</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>token和refresh token</title>
    <url>/2022/08/22/refresh%20token%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>待写</p>
<h2 id="2023年6月13日"><a href="#2023年6月13日" class="headerlink" title="2023年6月13日"></a>2023年6月13日</h2><p>先记录一下现在的一些想法。</p>
<p>今天中午看面经的时候一个问题：为什么token要存储在cookie或localstorage中，而不存储在session中？</p>
<p>这篇文章提到的其实是有将sessionid作为token的。</p>
<p><a href="https://blog.csdn.net/sunyctf/article/details/126509232">(40条消息) 什么是token？token是用来干嘛的？_token的作用_儒雅的烤地瓜的博客-CSDN博客</a></p>
<p>初步想法是token和session是两个不同的东西，且token应该存储在客户端，session是存储在服务端的。引申出了两者的作用的对比和一些最近的问题。</p>
<ol>
<li><p>token和seesion获得的数据？</p>
<p>目前的理解是：session存储登录用户的一些信息，包括状态信息，以及常说的购物车之类的东西。token应该是不能存储这么多内容的，但是可以通过携带token的请求去获取这些数据。</p>
<p>这就是网上提到的“session是通过空间换时间，token是通过时间换空间。”毕竟直接携带sessionid去请求session中的数据是更快的，但是也需要额外的空间去维护session中的数据。而携带token去请求这些数据更慢，但是不需要单独存储这些数据。</p>
<p>下面是c老师的一些描述。</p>
</li>
</ol>
<blockquote>
<p>这个描述是否正确。session存储了用户的相关信息，客户端通过携带sessionID去获取用户的相关信息。而token是用户的登录权限，用户携带token去向服务端获取需要的数据。客户端可以通过携带token去请求原本应该存储在session中的用户信息，而达到获取用户信息的效果。</p>
</blockquote>
<blockquote>
<p>您的描述基本正确，下面是对您的描述的一些补充说明：</p>
<ol>
<li>Session 存储用户的相关信息：Session 是一种在服务器端存储用户状态和相关数据的机制。当用户进行身份验证后，服务器会为用户创建一个唯一的 Session，并将相关信息存储在服务器端的内存或持久化存储中，通常是关联到一个 Session ID。用户在后续的请求中，可以通过携带这个 Session ID 来获取自己的相关信息。服务器根据 Session ID 识别用户，并提供对应的数据。</li>
<li>Token 是用户的登录权限：Token 是一种身份验证凭证，用于验证用户的身份和权限。当用户成功进行身份验证后，服务器会颁发一个 Token 给客户端。这个 Token 可以被客户端保存，并在后续的请求中携带给服务器。服务器会验证 Token 的有效性，如果有效，则对请求进行授权并提供相应的数据。Token 可以包含一些用户信息的声明，如用户ID、角色等，用于辅助服务器进行权限验证和处理。</li>
<li>客户端通过携带 Token 请求用户信息：客户端在获得有效的 Token 后，可以在后续的请求中将 Token 携带在请求的头部、参数或其他位置。服务器收到请求后，会验证 Token 的有效性，并根据 Token 所包含的用户信息来决定是否返回用户的相关信息。这样客户端可以直接通过携带 Token 请求用户信息，而无需通过 Session ID 去获取。</li>
</ol>
<p>需要注意的是，Token 和 Session 是两种不同的身份验证和授权机制。Token 是一种基于令牌的身份验证机制，通过颁发短期的 Token 来进行用户身份验证和授权。Session 则是一种基于服务器端存储的用户状态机制，通过在服务器端存储用户相关信息来维持用户会话和状态。</p>
</blockquote>
<ol start="2">
<li><p>为什么要给token设置一个较短的过期时间，然后通过refresh token来不断更新token的有效时间？</p>
<p>首先常说的token实际上叫做access token，作用是携带token去请求数据，所以access token会长期出现在http报文中，有些应用为了效率是不是用https的，所以被盗的风险更大。</p>
<p>设置较短的有效时间时间可以使token被盗后的危害降低，有效时间只有10分钟的话就只能用旧token十分钟。</p>
<p>然后是refresh token。refresh token只有在更新access token时才会出现在http请求中，其他时间一直存储在内存中的，被盗的风险低。</p>
<blockquote>
<p>at失效之后，再用rt去刷一次，刷的时候，可以同时把rt一起刷了<br>这样理论上rt只会在网络上过两次，一次是你获取的时候，一次是你使用的时候<br>因此rt被盗的风险远远小于at</p>
<p>要理解上述问题，首先要明白oauth2.0的设计规范。2.0支持四种不同的验证方式，其中双token是其中一种，对应的场景是第三方登陆场景。此种场景下第一次获取access_token需要用户点击，用code换取。但是如果2小时就要用户点击一次，显然不太友好，因此引入refresh_token。通常如果是购买的服务，有用。但是如果自己搭建了oauth服务，过度设计了。<br>————————————————<br>原文链接：<a href="https://blog.csdn.net/weixin_52405713/article/details/122734148">https://blog.csdn.net/weixin_52405713/article/details/122734148</a></p>
</blockquote>
</li>
</ol>
<blockquote>
<p>@xtinput 其实没必要那么复杂，refresh token 更像传统意义上的 session id ，能拿到这个信息的人，基本用不到这个信息就可以直接干坏事了。</p>
<p>现代架构之所以用 token ，是因为后端普遍采用分布式，各服务器之间同步状态（比如 session ）的开销很大，所以干脆不用状态，而是给个 token ，后端各自验证 token 的有效性而无需与其他服务器沟通，这就是所谓的 stateless 。</p>
<p>stateless 在绝大多数时候都没问题，但我们却不太可能实现彻底的无状态。比如用户修改了密码，服务端想强制他重新登录，这就得通知各个服务器不要再接受之前的 token 了。</p>
<p>要解决这个问题，常见的有 3 种方法：<br>1 、找个地方（内存、数据库等）记录合法的 token ，每次验证 token 都查一下这个 token 是否还在。<br>2 、找个地方（内存、数据库等）记录 token 的黑名单，每次验证 token 都查一下这个 token 是否在黑名单里。<br>3 、让 token 自己失效。</p>
<p>前两种都是有状态的方法，仍然避免不了状态同步的瓶颈，所以我们一般采用第三种方法。</p>
<p>那怎么让 token 自己失效呢？ token 里一般都有时间信息，所以只需把有效期设得短一点，不再更新它，它就过期失效了。</p>
<p>这就引出了更新的问题，怎么更新 token 呢？我们一般用另一个 token ，这就是所谓的 refresh token 。服务端收到 refresh token 以后，是要检查黑名单或者白名单的，所以更新 token 这一步是有状态的。只有 refresh token 有效，才会下发 access token ，这样就把对状态同步的需求限制到了一个很小的范围内，从而降低状态同步成本。</p>
<p>自此，有状态和无状态实现了有机结合，在一起过上了幸福快乐的日子。</p>
<p>[<a href="https://www.nuomiphp.com/t/61b4820013447c3409324111.html]">https://www.nuomiphp.com/t/61b4820013447c3409324111.html]</a>: </p>
</blockquote>
]]></content>
      <categories>
        <category>token</category>
      </categories>
      <tags>
        <tag>token</tag>
        <tag>身份认证</tag>
      </tags>
  </entry>
  <entry>
    <title>vue中watch的使用</title>
    <url>/2022/08/16/vue3%E4%B8%AD%E7%9A%84watch%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学习vue3拖拽逻辑时，看到了一种watch的用法：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">watchProps</span>(<span class="params"></span></span><br><span class="line"><span class="params">  props: <span class="built_in">any</span>,</span></span><br><span class="line"><span class="params">  limits: ReturnType&lt;<span class="keyword">typeof</span> initLimitSizeAndMethods&gt;</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; setWidth, setHeight, setLeft, setTop &#125; = limits;</span><br><span class="line">  <span class="title function_">watch</span>(</span><br><span class="line">    <span class="function">() =&gt;</span> props.<span class="property">w</span>,</span><br><span class="line">    <span class="function">(<span class="params">newVal: <span class="built_in">number</span></span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setWidth</span>(newVal);</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里watch监听的是一个函数的返回值，而不是直接监听一个变量。这里是为了每次 <code>watch</code> 函数运行时获取属性的最新值。</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>watch 监听 的是一个reactive的复杂类型中的某个变量 或者 obj对象中的 某个变量 时 就要是监听一个函数的返回值，如果是一个ref变量，就可以直接监听。</p>
<h2 id="watch相关"><a href="#watch相关" class="headerlink" title="watch相关"></a>watch相关</h2><p>在 Vue 中，<code>watch</code> 函数接收两个参数：<code>watcher</code> 和 <code>callback</code>。<code>watcher</code> 是一个函数，它返回 <code>watch</code> 函数的依赖值。当依赖值发生变化时，<code>callback</code> 函数会被触发。</p>
<p>对于响应式属性（通过 <code>ref</code> 或 <code>reactive</code> 创建），Vue 能够自动追踪它们的变化，并在每次变化时触发 <code>watch</code> 回调。但对于非响应式的普通属性，Vue 无法自动追踪其变化。</p>
<p><strong>通过将属性放在一个函数中返回，并将这个函数作为 <code>watcher</code>，可以在每次运行 <code>watch</code> 函数时获取属性的最新值。</strong>这样，在每次 <code>watch</code> 回调触发时，就能使用最新的属性值进行处理。</p>
<p>综上所述，将属性放在函数中返回是为了在每次 <code>watch</code> 运行时获取最新值，而不是为了让属性被追踪。如果属性是响应式的，Vue 可以自动追踪其变化；如果属性是非响应式的，需要通过将其放在函数中返回，手动获取最新值。</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>数据响应</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-js</title>
    <url>/2023/05/31/leetcode-js/</url>
    <content><![CDATA[<h2 id="2618-检查是否是类的对象实例"><a href="#2618-检查是否是类的对象实例" class="headerlink" title="2618.检查是否是类的对象实例"></a>2618.检查是否是类的对象实例</h2><p>请你编写一个函数，检查给定的对象是否是给定类或超类的实例。</p>
<p>可以传递给函数的数据类型没有限制。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：func = () =&gt; checkIfInstance(new Date(), Date)</span><br><span class="line">输出：true</span><br><span class="line">解释：根据定义，Date 构造函数返回的对象是 Date 的一个实例。</span><br></pre></td></tr></table></figure>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">checkIfInstanceOf</span>(<span class="params">obj: <span class="built_in">any</span>, classFunction: <span class="built_in">any</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(obj == <span class="literal">null</span> || obj == <span class="literal">undefined</span> || <span class="keyword">typeof</span> classFunction !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj) == classFunction.<span class="property"><span class="keyword">prototype</span></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        obj = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * checkIfInstanceOf(new Date(), Date); // true</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="2619-数组原型对象的最后一个元素"><a href="#2619-数组原型对象的最后一个元素" class="headerlink" title="2619.数组原型对象的最后一个元素"></a>2619.数组原型对象的最后一个元素</h2><p>请你编写一段代码实现一个数组方法，使任何数组都可以调用 <code>array.last()</code> 方法，这个方法将返回数组最后一个元素。如果数组中没有元素，则返回 <code>-1</code> 。</p>
<p><strong>示例 1 ：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：3</span><br><span class="line">解释：调用 nums.last() 后返回最后一个元素： 3。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2 ：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = []</span><br><span class="line">输出：-1</span><br><span class="line">解释：因为此数组没有元素，所以应该返回 -1。</span><br></pre></td></tr></table></figure>

<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable language_">global</span> &#123;</span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Array</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="title function_">last</span>(): T | -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">last</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">length</span> &lt;= <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>[<span class="variable language_">this</span>.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2620-计数器"><a href="#2620-计数器" class="headerlink" title="2620.计数器"></a>2620.计数器</h2><p>请你编写并返回一个 <strong>计数器</strong> 函数，它接收一个整型参数 n 。这个 <strong>计数器</strong> 函数最初返回 n，每次调用它时返回前一个值加 1 的值 ( <code>n</code> , <code>n + 1</code> , <code>n + 2</code> ，等等)。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">n = 10 </span><br><span class="line">[&quot;call&quot;,&quot;call&quot;,&quot;call&quot;]</span><br><span class="line">输出：[10,11,12]</span><br><span class="line">解释：</span><br><span class="line">counter() = 10 // 第一次调用 counter()，返回 n。</span><br><span class="line">counter() = 11 // 返回上次调用的值加 1。</span><br><span class="line">counter() = 12 // 返回上次调用的值加 1。</span><br></pre></td></tr></table></figure>

<h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createCounter</span>(<span class="params">n: <span class="built_in">number</span></span>): <span class="function">() =&gt;</span> <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> count = n;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * const counter = createCounter(10)</span></span><br><span class="line"><span class="comment"> * counter() // 10</span></span><br><span class="line"><span class="comment"> * counter() // 11</span></span><br><span class="line"><span class="comment"> * counter() // 12</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="2621-睡眠函数"><a href="#2621-睡眠函数" class="headerlink" title="2621.睡眠函数"></a>2621.睡眠函数</h2><p>请你编写一个异步函数，它接收一个正整数参数 <code>millis</code> ，并休眠这么多毫秒。要求此函数可以解析任何值。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：millis = 100</span><br><span class="line">输出：100</span><br><span class="line">解释：</span><br><span class="line">在 100ms 后此异步函数执行完时返回一个 Promise 对象</span><br><span class="line">let t = Date.now();</span><br><span class="line">sleep(100).then(() =&gt; &#123;</span><br><span class="line">  console.log(Date.now() - t); // 100</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">sleep</span>(<span class="params">millis: <span class="built_in">number</span></span>): <span class="title class_">Promise</span>&lt;<span class="built_in">void</span>&gt; &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(), millis);</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * let t = Date.now()</span></span><br><span class="line"><span class="comment"> * sleep(100).then(() =&gt; console.log(Date.now() - t)) // 100</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="2622-有时间限制的缓存"><a href="#2622-有时间限制的缓存" class="headerlink" title="2622.有时间限制的缓存"></a>2622.有时间限制的缓存</h2><p>编写一个类，它允许获取和设置键-值对，并且每个键都有一个 <strong>过期时间</strong> 。</p>
<p>该类有三个公共方法：</p>
<p><code>set(key, value, duration)</code> ：接收参数为整型键 <code>key</code> 、整型值 <code>value</code> 和以毫秒为单位的持续时间 <code>duration</code> 。一旦 <code>duration</code> 到期后，这个键就无法访问。如果相同的未过期键已经存在，该方法将返回 <code>true</code> ，否则返回 <code>false</code> 。如果该键已经存在，则它的值和持续时间都应该被覆盖。</p>
<p><code>get(key)</code> ：如果存在一个未过期的键，它应该返回这个键相关的值。否则返回 <code>-1</code> 。</p>
<p><code>count()</code> ：返回未过期键的总数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入： </span><br><span class="line">[&quot;TimeLimitedCache&quot;, &quot;set&quot;, &quot;get&quot;, &quot;count&quot;, &quot;get&quot;]</span><br><span class="line">[[], [1, 42, 100], [1], [], [1]]</span><br><span class="line">[0, 0, 50, 50, 150]</span><br><span class="line">输出： [null, false, 42, 1, -1]</span><br><span class="line">解释：</span><br><span class="line">在 t=0 时，缓存被构造。</span><br><span class="line">在 t=0 时，添加一个键值对 (1: 42) ，过期时间为 100ms 。因为该值不存在，因此返回false。</span><br><span class="line">在 t=50 时，请求 key=1 并返回值 42。</span><br><span class="line">在 t=50 时，调用 count() ，缓存中有一个未过期的键。</span><br><span class="line">在 t=100 时，key=1 到期。</span><br><span class="line">在 t=150 时，调用 get(1) ，返回 -1，因为缓存是空的。</span><br></pre></td></tr></table></figure>

<h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><h4 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h4><p>使用定时器，到时间之后直接删除map中的key。</p>
<p><strong>注意：ts中直接获取setTimeout获得的不是number，<code>window.setTimerout</code>获得的才是number</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TimeLimitedCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>&lt;<span class="built_in">number</span>, <span class="built_in">number</span>&gt;()</span><br><span class="line">    <span class="keyword">private</span> timers = <span class="keyword">new</span> <span class="title class_">Map</span>&lt;<span class="built_in">number</span>, <span class="built_in">any</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="title function_">set</span>(<span class="attr">key</span>: <span class="built_in">number</span>, <span class="attr">value</span>: <span class="built_in">number</span>, <span class="attr">duration</span>: <span class="built_in">number</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> res = <span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">has</span>(key);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">set</span>(key, value);</span><br><span class="line">        <span class="keyword">let</span> timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">delete</span>(key), duration);</span><br><span class="line">        <span class="built_in">clearTimeout</span>(<span class="variable language_">this</span>.<span class="property">timers</span>.<span class="title function_">get</span>(key));</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">timers</span>.<span class="title function_">set</span>(key, timer);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">get</span>(<span class="attr">key</span>: <span class="built_in">number</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">has</span>(key) ? <span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">get</span>(key) : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="title function_">count</span>(): <span class="built_in">number</span> &#123;</span><br><span class="line">        <span class="comment">// return [...this.map.keys()].length;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">map</span>.<span class="property">size</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h4><p>直接通过Data.now()来实现。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TimeLimitedCache</span> &#123;</span><br><span class="line">    cache = <span class="keyword">new</span> <span class="title class_">Map</span>&lt;<span class="built_in">number</span>, [<span class="built_in">number</span>, <span class="built_in">number</span>]&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="title function_">set</span>(<span class="attr">key</span>: <span class="built_in">number</span>, <span class="attr">value</span>: <span class="built_in">number</span>, <span class="attr">duration</span>: <span class="built_in">number</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">        <span class="keyword">const</span> item = <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">get</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (item) &#123;</span><br><span class="line">            item[<span class="number">0</span>] = now + duration;</span><br><span class="line">            item[<span class="number">1</span>] = value;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">set</span>(key, [now + duration, value]);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">get</span>(<span class="attr">key</span>: <span class="built_in">number</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">        <span class="keyword">const</span> item = <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">get</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (!item || now &gt; item[<span class="number">0</span>]) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> item[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">count</span>(): <span class="built_in">number</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">        <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> [key, item] <span class="keyword">of</span> <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (now &gt; item[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">delete</span>(key);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h4><p>使用闭包+defineProperty来控制数据的访问。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TimeLimitedCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> caches = &#123;&#125;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当连续set同一个key时，每一个定时器修改的都是自己作用域中的valid</span></span><br><span class="line">    <span class="title function_">set</span>(<span class="attr">key</span>: <span class="built_in">number</span>, <span class="attr">value</span>: <span class="built_in">number</span>, <span class="attr">duration</span>: <span class="built_in">number</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> flag = <span class="variable language_">this</span>.<span class="title function_">get</span>(key) != -<span class="number">1</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">let</span> valid = <span class="literal">true</span>;   <span class="comment">// 闭包保存当前key所对应的value和valid</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> valid = <span class="literal">false</span>, duration)   <span class="comment">// 到时间后将valid改为false</span></span><br><span class="line">        <span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(<span class="variable language_">this</span>.<span class="property">caches</span>, key, &#123;</span><br><span class="line">            <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(valid) &#123;</span><br><span class="line">                    <span class="keyword">return</span> value;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">enumerable</span>: <span class="literal">true</span>,   <span class="comment">// 让getter可以被覆盖和遍历</span></span><br><span class="line">            <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">get</span>(<span class="attr">key</span>: <span class="built_in">number</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">caches</span>[key] || -<span class="number">1</span>;  <span class="comment">// key不存在或者过期返回-1（注意有些key是没有getter的）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="title function_">count</span>(): <span class="built_in">number</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> k <span class="keyword">in</span> <span class="variable language_">this</span>.<span class="property">caches</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">get</span>(k <span class="keyword">as</span> <span class="built_in">any</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">                n++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2623-记忆函数"><a href="#2623-记忆函数" class="headerlink" title="2623.记忆函数"></a>2623.记忆函数</h2><p>请你编写一个函数，它接收另一个函数作为输入，并返回该函数的 <strong>记忆化</strong> 后的结果。</p>
<p><strong>记忆函数</strong> 是一个对于相同的输入永远不会被调用两次的函数。相反，它将返回一个缓存值。</p>
<p>你可以假设有 <strong>3</strong> 个可能的输入函数：<code>sum</code> 、<code>fib</code> 和 <code>factorial</code> 。</p>
<h3 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Fn</span> = <span class="function">(<span class="params">...params: <span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">any</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">memoize</span>(<span class="params">fn: Fn</span>): <span class="title class_">Fn</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>&lt;<span class="built_in">string</span>, <span class="built_in">any</span>&gt;();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> key = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(args);</span><br><span class="line">        <span class="keyword">if</span>(map.<span class="title function_">has</span>(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> map.<span class="title function_">get</span>(key)</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> result = <span class="title function_">fn</span>(...args);</span><br><span class="line">            map.<span class="title function_">set</span>(key, result);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * let callCount = 0;</span></span><br><span class="line"><span class="comment"> * const memoizedFn = memoize(function (a, b) &#123;</span></span><br><span class="line"><span class="comment"> *	 callCount += 1;</span></span><br><span class="line"><span class="comment"> *   return a + b;</span></span><br><span class="line"><span class="comment"> * &#125;)</span></span><br><span class="line"><span class="comment"> * memoizedFn(2, 3) // 5</span></span><br><span class="line"><span class="comment"> * memoizedFn(2, 3) // 5</span></span><br><span class="line"><span class="comment"> * console.log(callCount) // 1 </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>一开始直接将<code>[...args]</code>作为map的key，后面出现了错误。思考了一下，应该是map只会将引用数据类型的地址作为key，而不是值，所以最好将key设置为基本数据类型。</p>
<blockquote>
<p>在 TypeScript 中，数组同样可以作为 Map 的键，但有一些限制和注意事项：</p>
<ol>
<li>TypeScript 的类型系统会强制执行严格的键类型检查。这意味着在声明 Map 的类型时，需要指定数组作为键的类型。</li>
<li>与 JavaScript 类似，数组作为 Map 键时会被转换为字符串作为实际的键值存储。因此，相同的数组元素但顺序不同的数组会被视为不同的键。</li>
</ol>
</blockquote>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">map</span>: <span class="title class_">Map</span>&lt;<span class="built_in">number</span>[], <span class="built_in">string</span>&gt; = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">key1</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="attr">key2</span>: <span class="built_in">number</span>[] = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">map.<span class="title function_">set</span>(key1, <span class="string">&#x27;Value 1&#x27;</span>);</span><br><span class="line">map.<span class="title function_">set</span>(key2, <span class="string">&#x27;Value 2&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">get</span>(key1)); <span class="comment">// 输出: Value 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">get</span>(key2)); <span class="comment">// 输出: Value 2</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">get</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])); <span class="comment">// 输出: undefined，因为新数组和 key1 不是同一个引用</span></span><br></pre></td></tr></table></figure>

<h2 id="2624-蜗牛排序"><a href="#2624-蜗牛排序" class="headerlink" title="2624.蜗牛排序"></a>2624.蜗牛排序</h2><p>请你编写一段代码为所有数组实现 <code>snail(rowsCount，colsCount)</code> 方法，该方法将 1D 数组转换为以蜗牛排序的模式的 2D 数组。无效的输入值应该输出一个空数组。当 <code>rowsCount * colsCount !==``nums.length</code> 时。这个输入被认为是无效的。</p>
<p>蜗牛排序从左上角的单元格开始，从当前数组的第一个值开始。然后，它从上到下遍历第一列，接着移动到右边的下一列，并从下到上遍历它。将这种模式持续下去，每列交替变换遍历方向，直到覆盖整个数组。例如，当给定输入数组 <code>[19, 10, 3, 7, 9, 8, 5, 2, 1, 17, 16, 14, 12, 18, 6, 13, 11, 20, 4, 15]</code> ，当 <code>rowsCount = 5</code> 且 <code>colsCount = 4</code> 时，需要输出矩阵如下图所示。注意，矩阵沿箭头方向对应于原数组中数字的顺序</p>
<p><img src="https://assets.leetcode.com/uploads/2023/04/10/screen-shot-2023-04-10-at-100006-pm.png" alt="Traversal Diagram"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">nums = [19, 10, 3, 7, 9, 8, 5, 2, 1, 17, 16, 14, 12, 18, 6, 13, 11, 20, 4, 15]</span><br><span class="line">rowsCount = 5</span><br><span class="line">colsCount = 4</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line"> [19,17,16,15],</span><br><span class="line"> [10,1,14,4],</span><br><span class="line"> [3,2,12,20],</span><br><span class="line"> [7,5,18,11],</span><br><span class="line"> [9,8,6,13]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h3><h4 id="解法一-1"><a href="#解法一-1" class="headerlink" title="解法一"></a>解法一</h4><p>思路主要就是写一个数组作为存放结果的容器res，然后按照蜗牛排序的顺序遍历这个res来往里面填内容。我用了两个遍历来模拟正方向和反方向</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable language_">global</span> &#123;</span><br><span class="line">  <span class="keyword">interface</span> <span class="title class_">Array</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="title function_">snail</span>(<span class="attr">rowsCount</span>: <span class="built_in">number</span>, <span class="attr">colsCount</span>: <span class="built_in">number</span>): <span class="built_in">number</span>[][];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">snail</span> = <span class="keyword">function</span>(<span class="params">rowsCount: <span class="built_in">number</span>, colsCount: <span class="built_in">number</span></span>): <span class="built_in">number</span>[][] &#123;</span><br><span class="line">    <span class="keyword">if</span>(rowsCount * colsCount !== <span class="variable language_">this</span>.<span class="property">length</span>) <span class="keyword">return</span> []; </span><br><span class="line">    <span class="keyword">let</span> res = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: rowsCount &#125;, <span class="function">() =&gt;</span> <span class="title class_">Array</span>(colsCount).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>, isResverse = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> col = <span class="number">0</span>; col &lt; colsCount; col++ ) &#123;</span><br><span class="line">        <span class="keyword">if</span>(isResverse) &#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">let</span> row = rowsCount - <span class="number">1</span>; row &gt;= <span class="number">0</span>; row--) &#123;</span><br><span class="line">            res[row][col] = <span class="variable language_">this</span>[count++];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">let</span> row = <span class="number">0</span>; row &lt; rowsCount; row++) &#123;</span><br><span class="line">            res[row][col] = <span class="variable language_">this</span>[count++];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        isResverse = !isResverse</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * const arr = [1,2,3,4];</span></span><br><span class="line"><span class="comment"> * arr.snail(1,4); // [[1,2,3,4]]</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>gpt简化的版本</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">snail</span> = <span class="keyword">function</span>(<span class="params">rowsCount: <span class="built_in">number</span>, colsCount: <span class="built_in">number</span></span>): <span class="built_in">number</span>[][] &#123;</span><br><span class="line">    <span class="keyword">if</span> (rowsCount * colsCount !== <span class="variable language_">this</span>.<span class="property">length</span>) <span class="keyword">return</span> [];</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">const</span> <span class="attr">res</span>: <span class="built_in">number</span>[][] = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: rowsCount &#125;, <span class="function">() =&gt;</span> <span class="title class_">Array</span>(colsCount).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> isReverse = <span class="literal">false</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> col = <span class="number">0</span>; col &lt; colsCount; col++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> row = isReverse ? rowsCount - <span class="number">1</span> : <span class="number">0</span>; isReverse ? row &gt;= <span class="number">0</span> : row &lt; rowsCount; isReverse ? row-- : row++) &#123;</span><br><span class="line">            res[row][col] = <span class="variable language_">this</span>[count++];</span><br><span class="line">        &#125;</span><br><span class="line">        isReverse = !isReverse;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解法二-1"><a href="#解法二-1" class="headerlink" title="解法二"></a>解法二</h4><p>使用数学方法，通过数学计算来选择要填入的数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">rowsCount</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">colsCount</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">Array&lt;Array&lt;number&gt;&gt;</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">snail</span> = <span class="keyword">function</span>(<span class="params">rowsCount, colsCount</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">length</span> !== rowsCount * colsCount) &#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; rowsCount; i++) &#123;</span><br><span class="line">        res.<span class="title function_">push</span>([]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> seq = <span class="literal">true</span>; <span class="comment">// 正向还是逆向</span></span><br><span class="line">    <span class="keyword">let</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        res[start].<span class="title function_">push</span>(<span class="variable language_">this</span>[i]);</span><br><span class="line">        <span class="keyword">if</span> (seq) &#123;</span><br><span class="line">            <span class="keyword">if</span> (start === rowsCount - <span class="number">1</span>) &#123;</span><br><span class="line">                seq = <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (start === <span class="number">0</span>) &#123;</span><br><span class="line">                seq = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                start--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * const arr = [1,2,3,4];</span></span><br><span class="line"><span class="comment"> * arr.snail(1,4); // [[1,2,3,4]]</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="给定row-col生成一个空数组的方法-Array-from-Array-fill-Array-map"><a href="#给定row-col生成一个空数组的方法-Array-from-Array-fill-Array-map" class="headerlink" title="给定row col生成一个空数组的方法(Array.from()  Array.fill()  Array.map())"></a>给定row col生成一个空数组的方法(Array.from()  Array.fill()  Array.map())</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// from</span></span><br><span class="line"><span class="keyword">const</span> rowsCount = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> colsCount = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> matrix = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: rowsCount &#125;, <span class="function">() =&gt;</span> <span class="title class_">Array</span>(colsCount));</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matrix);</span><br><span class="line"></span><br><span class="line"><span class="comment">// fill</span></span><br><span class="line"><span class="keyword">const</span> rowsCount = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> colsCount = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> matrix = <span class="title class_">Array</span>(rowsCount).<span class="title function_">fill</span>([]);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matrix);</span><br><span class="line"></span><br><span class="line"><span class="comment">// map</span></span><br><span class="line"><span class="keyword">const</span> rowsCount = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> colsCount = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> matrix = <span class="title class_">Array</span>(rowsCount).<span class="title function_">map</span>(<span class="function">() =&gt;</span> []);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matrix);</span><br></pre></td></tr></table></figure>

<h2 id="2625-扁平化嵌套数组"><a href="#2625-扁平化嵌套数组" class="headerlink" title="2625.扁平化嵌套数组"></a>2625.扁平化嵌套数组</h2><p>请你编写一个函数，它接收一个 <strong>多维数组</strong> <code>arr</code> 和它的深度 <code>n</code> ，并返回该数组的 <strong>扁平化</strong> 后的结果。</p>
<p><strong>多维数组</strong> 是一种包含整数或其他 <strong>多维数组</strong> 的递归数据结构。</p>
<p>数组 <strong>扁平化</strong> 是对数组的一种操作，定义是将原数组部分或全部子数组删除，并替换为该子数组中的实际元素。只有当嵌套的数组深度大于 <code>n</code> 时，才应该执行扁平化操作。第一层数组中元素的深度被认为是 0。</p>
<p>请在没有使用内置方法 <code>Array.flat</code> 的前提下解决这个问题。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入</span><br><span class="line">arr = [1, 2, 3, [4, 5, 6], [7, 8, [9, 10, 11], 12], [13, 14, 15]]</span><br><span class="line">n = 0</span><br><span class="line">输出</span><br><span class="line">[1, 2, 3, [4, 5, 6], [7, 8, [9, 10, 11], 12], [13, 14, 15]]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">传递深度 n=0 的多维数组将始终得到原始数组。这是因为 子数组(0) 的最小可能的深度不小于 n=0 。因此，任何子数组都不应该被平面化。</span><br></pre></td></tr></table></figure>

<h3 id="题解-7"><a href="#题解-7" class="headerlink" title="题解"></a>题解</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MultiDimensionalArray</span> = (<span class="built_in">number</span> | <span class="title class_">MultiDimensionalArray</span>)[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> flat = <span class="keyword">function</span> (<span class="params">arr:  MultiDimensionalArray, n: <span class="built_in">number</span></span>):  <span class="title class_">MultiDimensionalArray</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr.<span class="property">reduce</span>&lt;<span class="title class_">MultiDimensionalArray</span>&gt;(<span class="function">(<span class="params">prev, item</span>) =&gt;</span> &#123;</span><br><span class="line">        item <span class="keyword">instanceof</span> <span class="title class_">Array</span> ? prev.<span class="title function_">push</span>(...<span class="title function_">flat</span>(item, n - <span class="number">1</span>)) : prev.<span class="title function_">push</span>(item)</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;, [])</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><p>如果是</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, item</span>) =&gt;</span> &#123;</span><br><span class="line">        item <span class="keyword">instanceof</span> <span class="title class_">Array</span> ? prev.<span class="title function_">push</span>(...<span class="title function_">flat</span>(item, n - <span class="number">1</span>)) : prev.<span class="title function_">push</span>(item)</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;, [])</span><br></pre></td></tr></table></figure>

<p>会触发类型错误，需要加上类型。</p>
<h2 id="2626-数组归约运算"><a href="#2626-数组归约运算" class="headerlink" title="2626.数组归约运算"></a>2626.数组归约运算</h2><p>请你编写一个函数，它的参数为一个整数数组 <code>nums</code> 、一个计算函数 <code>fn</code> 和初始值 init 。返回一个数组 <strong>归约后</strong> 的值。</p>
<p>你可以定义一个数组 <strong>归约后</strong> 的值，然后应用以下操作： <code>val = fn(init, nums[0])</code> ， <code>val = fn(val, nums[1])</code> ， <code>val = fn(val, nums[2])</code> ，<code>...</code> 直到数组中的每个元素都被处理完毕。返回 <code>val</code> 的最终值。</p>
<p>如果数组的长度为 0，它应该返回 <code>init</code> 的值。</p>
<p>请你在不使用内置数组方法的 <code>Array.reduce</code> 前提下解决这个问题。</p>
<h3 id="题解-8"><a href="#题解-8" class="headerlink" title="题解"></a>题解</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Fn</span> = <span class="function">(<span class="params">accum: <span class="built_in">number</span>, curr: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reduce</span>(<span class="params">nums: <span class="built_in">number</span>[], fn: Fn, init: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    nums.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">        init = <span class="title function_">fn</span>(init, value);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> init;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2627-函数防抖"><a href="#2627-函数防抖" class="headerlink" title="2627.函数防抖"></a>2627.函数防抖</h2><h3 id="题解-9"><a href="#题解-9" class="headerlink" title="题解"></a>题解</h3><p><strong>fn.apply的时候直接用this和args就行。</strong></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> F = <span class="function">(<span class="params">...p: <span class="built_in">any</span>[]</span>) =&gt;</span> <span class="built_in">any</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn: F, t: <span class="built_in">number</span></span>): F &#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(timer) &#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        &#125;</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args), t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * const log = debounce(console.log, 100);</span></span><br><span class="line"><span class="comment"> * log(&#x27;Hello&#x27;); // cancelled</span></span><br><span class="line"><span class="comment"> * log(&#x27;Hello&#x27;); // cancelled</span></span><br><span class="line"><span class="comment"> * log(&#x27;Hello&#x27;); // Logged at t=100ms</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="2628-完全相等的-JSON-字符串"><a href="#2628-完全相等的-JSON-字符串" class="headerlink" title="2628.完全相等的 JSON 字符串"></a>2628.完全相等的 JSON 字符串</h2><p>给定两个对象 <code>o1</code> 和 <code>o2</code> ，请你检查它们是否 <strong>完全相等</strong> 。</p>
<p>对于两个 <strong>完全相等</strong> 的对象，它们必须包含相同的键，并且相关的值也必须 <strong>完全相等</strong> 。如果两个对象通过了 <code>===</code> 相等性检查，它们也被认为是 <strong>完全相等</strong> 的。</p>
<p>你可以假设这两个对象都是 <code>JSON.parse</code> 的输出。换句话说，它们是有效的 <code>JSON</code> 。</p>
<p>请你在不使用 lodash 的 <code>_.isEqual()</code> 函数的前提下解决这个问题。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：o1 = &#123;&quot;x&quot;:1,&quot;y&quot;:2&#125;, o2 = &#123;&quot;x&quot;:1,&quot;y&quot;:2&#125;</span><br><span class="line">输出：true</span><br><span class="line">输入：键和值完全匹配。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：o1 = &#123;&quot;y&quot;:2,&quot;x&quot;:1&#125;, o2 = &#123;&quot;x&quot;:1,&quot;y&quot;:2&#125;</span><br><span class="line">输出：true</span><br><span class="line">解释：尽管键的顺序不同，但它们仍然完全匹配。</span><br></pre></td></tr></table></figure>

<h3 id="题解-10"><a href="#题解-10" class="headerlink" title="题解"></a>题解</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">areDeeplyEqual</span>(<span class="params">o1: <span class="built_in">any</span>, o2: <span class="built_in">any</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(o1) !== <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(o2)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(o1 !== <span class="literal">null</span> &amp;&amp; <span class="keyword">typeof</span> o1 === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(o1).<span class="property">length</span> === <span class="title class_">Object</span>.<span class="title function_">keys</span>(o2).<span class="property">length</span> &amp;&amp; </span><br><span class="line">            <span class="title class_">Object</span>.<span class="title function_">entries</span>(o1).<span class="title function_">every</span>(</span><br><span class="line">                <span class="function">(<span class="params">[key, value]</span>) =&gt;</span> <span class="title function_">areDeeplyEqual</span>(value, o2[key])</span><br><span class="line">            )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o1 === o2</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Object-entries（）"><a href="#Object-entries（）" class="headerlink" title="Object.entries（）"></a>Object.entries（）</h3><p>entries() 方法返回一个新的Array Iterator对象，该对象包含数组中每个索引的键&#x2F;值对。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const obj = &#123; foo: &#x27;bar&#x27;, baz: 42 &#125;;</span><br><span class="line">Object.entries(obj)</span><br><span class="line">//输出 [ [&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 42] ]</span><br></pre></td></tr></table></figure>

<h2 id="2629-复合函数"><a href="#2629-复合函数" class="headerlink" title="2629.复合函数"></a>2629.复合函数</h2><p>请你编写一个函数，它接收一个函数数组 <code>[f1, f2, f3，…， fn]</code> ，并返回一个新的函数 <code>fn</code> ，它是函数数组的 <strong>复合函数</strong> 。</p>
<p><code>[f(x)， g(x)， h(x)]</code> 的 <strong>复合函数</strong> 为 <code>fn(x) = f(g(h(x)))</code> 。</p>
<p>一个空函数列表的 <strong>复合函数</strong> 是 <strong>恒等函数</strong> <code>f(x) = x</code> 。</p>
<p>你可以假设数组中的每个函数接受一个整型参数作为输入，并返回一个整型作为输出。</p>
<h3 id="题解-11"><a href="#题解-11" class="headerlink" title="题解"></a>题解</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> F = <span class="function">(<span class="params">x: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">compose</span>(<span class="params">functions: F[]</span>): F &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> functions.<span class="title function_">reduceRight</span>(<span class="function">(<span class="params">prev, fn</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">fn</span>(prev)</span><br><span class="line">        &#125;, x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * const fn = compose([x =&gt; x + 1, x =&gt; 2 * x])</span></span><br><span class="line"><span class="comment"> * fn(4) // 9</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="reduceRight"><a href="#reduceRight" class="headerlink" title="reduceRight()"></a>reduceRight()</h3><p><code>reduceRight</code> 方法用于从数组的最后一个元素开始，从右到左地对数组的元素进行迭代操作，并根据提供的回调函数来累积结果。在回调函数中，第一个参数是累加器（初始值为最后一个元素），第二个参数是当前正在处理的元素。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sum = numbers.<span class="title function_">reduceRight</span>(<span class="function">(<span class="params">accumulator, currentValue</span>) =&gt;</span> accumulator + currentValue);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sum); <span class="comment">// Output: 15</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> concatenated = numbers.<span class="title function_">reduceRight</span>(<span class="function">(<span class="params">accumulator, currentValue</span>) =&gt;</span> <span class="string">`<span class="subst">$&#123;accumulator&#125;</span>-<span class="subst">$&#123;currentValue&#125;</span>`</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(concatenated); <span class="comment">// Output: 5-4-3-2-1</span></span><br></pre></td></tr></table></figure>

<h2 id="2630-记忆函数（二）"><a href="#2630-记忆函数（二）" class="headerlink" title="2630.记忆函数（二）"></a>2630.记忆函数（二）</h2><p>现给定一个函数 <code>fn</code> ，返回该函数的一个 <strong>记忆化</strong> 版本。</p>
<p>一个 <strong>记忆化</strong> 的函数是一个函数，它不会被相同的输入调用两次。而是会返回一个缓存的值。</p>
<p>函数 <code>fn</code> 可以是任何函数，对它所接受的值类型没有任何限制。如果两个输入值在 JavaScript 中使用 <code>===</code> 运算符比较时相等，则它们被视为相同。</p>
<h3 id="与（一）的区别"><a href="#与（一）的区别" class="headerlink" title="与（一）的区别"></a>与（一）的区别</h3><p>（一）单纯比较传入参数是否相同，其中{}和{}判断为一种参数，实际上两个对象是不同的。所以这里不能再单纯的使用字符串来进行比较。</p>
<h3 id="题解-12"><a href="#题解-12" class="headerlink" title="题解"></a>题解</h3><h4 id="方法一-双Map"><a href="#方法一-双Map" class="headerlink" title="方法一 双Map"></a>方法一 双Map</h4><p>使用一个map来将args作为key来存储，另一个map存储函数的运行结果。使用map自带的has来判断传入的引用数据类型是否相同，因为这时他们比较的是地址。</p>
<p>把每一个参数用<code>Map</code>存储，并赋予一个不重复的ID，最简单的实现就是ID自增即可。然后把每个ID串起来成为字符串去另外一个<code>Map</code>里面查询这个ID组合是否存在过。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Function</span>&#125; <span class="variable">fn</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">memoize</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> argMap = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">const</span> argsMap = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">let</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> key = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> args) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!argMap.<span class="title function_">has</span>(item)) argMap.<span class="title function_">set</span>(item, id++);</span><br><span class="line">            key += argMap.<span class="title function_">get</span>(item) + <span class="string">&quot;-&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (argsMap.<span class="title function_">has</span>(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> argsMap.<span class="title function_">get</span>(key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title function_">fn</span>(...args);</span><br><span class="line">            argsMap.<span class="title function_">set</span>(key, res);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法二-前缀字典树"><a href="#方法二-前缀字典树" class="headerlink" title="方法二 前缀字典树"></a>方法二 前缀字典树</h4><blockquote>
<p>把[…args]看做一个连续的查询，每次查询都是一个新的字典（Map），这样只要其中一个查询跟已有的路径不一样都会产生新的字典（查询路径）。</p>
<p>具体实现还需要考虑最后结果的储存，因为字典只能解决不同查询对应不同的路径，但查询结束后需要有个地方找到之前已经存在的值，在路径查询结束后，查询一下是否存在旧值，如果有，返回旧值，如果没有，调用方法解算值并存储，具体有3种实现路径：</p>
<p>把结果当做一次查询放在最后的最后，只是这个查询都是用同样的名字，可以是一个特定的对象，可以是一个不可能出现的字符串，更便捷的是用Symbol()生成一个独一无二对象，然后以此作为最后的结果存在最后的Map里面；<br>用一个对象把Map和结果打包起来，类似这样{map: new Map(), result: undefined}，最后查询result是否等于undefined就知道是否有旧值了，这样相对比较简单，但需要使用额外的空间存放很多多余的对象；<br>第三种方案其实和第二种是一样的，只是具体手法不一样，可以扩展Map或者继承Map并添加一个result属性，在class关键词操作下代码量较少。当前了如果不是真实工程文件，可以直接在最后的Map对象上挂一个”野“属性map._result &#x3D; res，也是可以，不过不是正路，不做具体讨论；</p>
</blockquote>
<p>实际上就是将传入的参数生成一个树，并且给每个节点赋予一个属性<code>result</code>，如果没有这个节点则生成节点，有节点则判断是否有属性<code>result</code>，有的话直接取值，不需要再次执行函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DictNode</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Map</span>&#123;</span><br><span class="line">    <span class="comment">// 题目测试用例所以得到的结果都没有undefined，如果题目表示结果可能是任务值，改方法需要多增加一个变量save=false，用于判断查询路径的末端是否已经存在过旧值</span></span><br><span class="line">    res = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123; <span class="variable language_">super</span>() &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">memoize</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> root = <span class="keyword">new</span> <span class="title class_">DictNode</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> dict = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> args) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dict.<span class="title function_">has</span>(item)) dict.<span class="title function_">set</span>(item, <span class="keyword">new</span> <span class="title class_">DictNode</span>());</span><br><span class="line">            dict = dict.<span class="title function_">get</span>(item);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dict.<span class="property">res</span> === <span class="literal">undefined</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title function_">fn</span>(...args);</span><br><span class="line">            <span class="comment">// 这样操作其实跟野属性没有区别，更好的方法是加一个方法用于修改这个`.res`值</span></span><br><span class="line">            dict.<span class="property">res</span> = res;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> dict.<span class="property">res</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2631-分组函数"><a href="#2631-分组函数" class="headerlink" title="2631.分组函数"></a>2631.分组函数</h2><p>请你编写一段可应用于所有数组的代码，使任何数组调用 <code>array. groupBy(fn)</code> 方法时，它返回对该数组 <strong>分组后</strong> 的结果。</p>
<p>数组 <strong>分组</strong> 是一个对象，其中的每个键都是 <code>fn(arr[i])</code> 的输出的一个数组，该数组中含有原数组中具有该键的所有项。</p>
<p>提供的回调函数 <code>fn</code> 将接受数组中的项并返回一个字符串类型的键。</p>
<p>每个值列表的顺序应该与元素在数组中出现的顺序相同。任何顺序的键都是可以接受的。</p>
<p>请在不使用 lodash 的 <code>_.groupBy</code> 函数的前提下解决这个问题。</p>
<h3 id="题解-13"><a href="#题解-13" class="headerlink" title="题解"></a>题解</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable language_">global</span> &#123;</span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Array</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="title function_">groupBy</span>(<span class="attr">fn</span>: <span class="function">(<span class="params">item: T</span>) =&gt;</span> <span class="built_in">string</span>): <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, T[]&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">groupBy</span> = <span class="keyword">function</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">ans</span>: <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="built_in">any</span>[]&gt; = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> <span class="variable language_">this</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> res = <span class="title function_">fn</span>(item);</span><br><span class="line">        <span class="comment">// res是执行fn后返回的键， ans中没有res键则建一个，有的话直接添加元素</span></span><br><span class="line">        (ans[res] ?? (ans[res] = [])).<span class="title function_">push</span>(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * [1,2,3].groupBy(String) // &#123;&quot;1&quot;:[1],&quot;2&quot;:[2],&quot;3&quot;:[3]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="2632-柯里化"><a href="#2632-柯里化" class="headerlink" title="2632.柯里化"></a>2632.柯里化</h2><p>请你编写一个函数，它接收一个其他的函数，并返回该函数的 <strong>柯里化</strong> 后的形式。</p>
<p><strong>柯里化</strong> 函数的定义是接受与原函数相同数量或更少数量的参数，并返回另一个 <strong>柯里化</strong> 后的函数或与原函数相同的值。</p>
<p>实际上，当你调用原函数，如 <code>sum(1,2,3)</code> 时，它将调用 <strong>柯里化</strong> 函数的某个形式，如 <code>csum(1)(2)(3)</code>， <code>csum(1)(2,3)</code>， <code>csum(1,2)(3)</code>，或 <code>csum(1,2,3)</code> 。所有调用 <strong>柯里化</strong> 函数的方法都应该返回与原始函数相同的值。</p>
<h3 id="题解-14"><a href="#题解-14" class="headerlink" title="题解"></a>题解</h3><p>凡是依赖curried函数外部闭包变量保存参数值的做法虽然能通过测试，但都存在不能复用中间函数的问题 正确思路：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">curry</span>(<span class="params">fn: <span class="built_in">Function</span></span>): <span class="title class_">Function</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">curried</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> f = fn.<span class="title function_">bind</span>(<span class="literal">undefined</span>, ...args);</span><br><span class="line">        <span class="keyword">if</span>(f.<span class="property">length</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="title function_">f</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">curry</span>(f);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">curry</span>(<span class="params">fn</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">curried</span>(<span class="params">...args</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (args.<span class="property">length</span> &gt;= fn.<span class="property">length</span>) <span class="keyword">return</span> <span class="title function_">fn</span>(...args)</span><br><span class="line">        <span class="keyword">return</span> <span class="function">(<span class="params">...args2</span>) =&gt;</span> <span class="title function_">curried</span>(...args, ...args2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2633-将对象转换为JSON字符串"><a href="#2633-将对象转换为JSON字符串" class="headerlink" title="2633.将对象转换为JSON字符串"></a>2633.将对象转换为JSON字符串</h2><p>现给定一个对象，返回该对象的有效 JSON 字符串。你可以假设这个对象只包括字符串、整数、数组、对象、布尔值和 null。返回的字符串不能包含额外的空格。键的返回顺序应该与 <code>Object.keys()</code> 的顺序相同。</p>
<p>请你在不使用内置方法 <code>JSON.stringify</code> 的前提下解决这个问题。</p>
<h3 id="题解-15"><a href="#题解-15" class="headerlink" title="题解"></a>题解</h3><p>因为传入的一定是一个对象，所以首先遍历的一定是对象，所以即使对象中包含的是基本数据类型，那么也是会先进行一次<strong>第1种情况</strong>的流程，然后将键值分开转换。</p>
<p>共分四种情况：</p>
<ol>
<li>对象：递归遍历对象中的属性，并且将键和值都转换为字符串，外面包裹一个<code>&#123;&#125;</code>；</li>
<li>数组：递归遍历数组中的元素，不需要保留数组的index，只需要将值变为字符串，外面包裹一个<code>[]</code>;</li>
<li>null：返回字符串’null’；</li>
<li>字符串：返回带 “” 的字符串值；</li>
<li>基本数据类型：返回字符串化的基本数据类型。</li>
</ol>
<p><strong>注意判断顺序，</strong>null和array也属于object。所以要先判断null和array再判断object。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">jsonStringify</span>(<span class="params"><span class="built_in">object</span>: <span class="built_in">any</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">object</span> === <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;null&quot;</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(<span class="built_in">object</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`[<span class="subst">$&#123;<span class="built_in">object</span>.map(jsonStringify).join(<span class="string">&quot;,&quot;</span>)&#125;</span>]`</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="built_in">object</span> === <span class="string">&quot;object&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`&#123;<span class="subst">$&#123;<span class="built_in">Object</span>.keys(<span class="built_in">object</span>).map(key =&gt; <span class="string">`&quot;<span class="subst">$&#123;key&#125;</span>&quot;:<span class="subst">$&#123;jsonStringify(<span class="built_in">object</span>[key])&#125;</span>`</span>)&#125;</span>&#125;`</span> </span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="built_in">object</span> === <span class="string">&quot;string&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`&quot;<span class="subst">$&#123;<span class="built_in">object</span>&#125;</span>&quot;`</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">String</span>(<span class="built_in">object</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2634-过滤数组中的元素"><a href="#2634-过滤数组中的元素" class="headerlink" title="2634.过滤数组中的元素"></a>2634.过滤数组中的元素</h2><p>请你编写一个函数，该函数接受一个整数数组参数 <code>arr</code> 和一个过滤函数 <code>fn</code>，并返回一个过滤后元素数量较少或元素数量相等的新数组。</p>
<p>返回的数组应该只包含通过过滤函数 <code>fn(arr[i]， i)</code> 计算后为真值的元素。</p>
<p>请你在不使用内置函数 <code>Array.filter</code> 的前提下解决该问题。</p>
<h3 id="题解-16"><a href="#题解-16" class="headerlink" title="题解"></a>题解</h3><p>总体都是遍历的思路。</p>
<h4 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h4><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">filter</span>(<span class="params">arr: <span class="built_in">number</span>[], fn: (n: <span class="built_in">number</span>, i: <span class="built_in">number</span>) =&gt; <span class="built_in">any</span></span>): <span class="built_in">number</span>[] &#123;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_">fn</span>(item, index))</span><br><span class="line">            res.<span class="title function_">push</span>(item)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> filter = <span class="keyword">function</span>(<span class="params">arr, fn</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">pre, cur,index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">fn</span>(cur,index)) &#123;</span><br><span class="line">            pre.<span class="title function_">push</span>(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;, [])</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2635-转换数组中的每个元素"><a href="#2635-转换数组中的每个元素" class="headerlink" title="2635.转换数组中的每个元素"></a>2635.转换数组中的每个元素</h2><p>编写一个函数，这个函数接收一个整数数组 <code>arr</code> 和一个映射函数 <code>fn</code> ，通过该映射函数返回一个新的数组。</p>
<p>返回数组的创建语句应为 <code>returnedArray[i] = fn(arr[i], i)</code> 。</p>
<p>请你在不使用内置方法 <code>Array.map</code> 的前提下解决这个问题。</p>
<h3 id="题解-17"><a href="#题解-17" class="headerlink" title="题解"></a>题解</h3><h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">map</span>(<span class="params">arr: <span class="built_in">number</span>[], fn: (n: <span class="built_in">number</span>, i: <span class="built_in">number</span>) =&gt; <span class="built_in">number</span></span>): <span class="built_in">number</span>[] &#123;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        res.<span class="title function_">push</span>(<span class="title function_">fn</span>(arr[i], i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="reduce-1"><a href="#reduce-1" class="headerlink" title="reduce"></a>reduce</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">function</span>(<span class="params">arr, fn</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">p, c, i</span>) =&gt;</span> (p.<span class="title function_">push</span>(fn.<span class="title function_">apply</span>(<span class="literal">null</span>, [c, i])),p) , [])</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="from"><a href="#from" class="headerlink" title="from"></a>from</h4><p>转换类数组为数组的同时，可以进行类似map的操作，返回值为一个新数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">function</span>(<span class="params">arr, fn</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(arr, fn);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2636-Promise对象池"><a href="#2636-Promise对象池" class="headerlink" title="2636.Promise对象池"></a>2636.Promise对象池</h2><p>请你编写一个异步函数 <code>promisePool</code> ，它接收一个异步函数数组 <code>functions</code> 和 <strong>池限制</strong> <code>n</code>。它应该返回一个 promise 对象，当所有输入函数都执行完毕后，promise 对象就执行完毕。</p>
<p><strong>池限制</strong> 定义是一次可以挂起的最多 promise 对象的数量。<code>promisePool</code> 应该开始执行尽可能多的函数，并在旧的 promise 执行完毕后继续执行新函数。<code>promisePool</code> 应该先执行 <code>functions[i]</code>，再执行 <code>functions[i + 1]</code>，然后执行 <code>functions[i + 2]</code>，等等。当最后一个 promise 执行完毕时，<code>promisePool</code> 也应该执行完毕。</p>
<p>例如，如果 <code>n = 1</code> , <code>promisePool</code> 在序列中每次执行一个函数。然而，如果 <code>n = 2</code> ，它首先执行两个函数。当两个函数中的任何一个执行完毕后，再执行第三个函数(如果它是可用的)，依此类推，直到没有函数要执行为止。</p>
<p>你可以假设所有的 <code>functions</code> 都不会被拒绝。对于 <code>promisePool</code> 来说，返回一个可以解析任何值的 promise 都是可以接受的。</p>
<h3 id="题解-18"><a href="#题解-18" class="headerlink" title="题解"></a>题解</h3><p>跟TaskQueue的题很像，大致思路是搞个函数每次从queue里取一个执行，如果还有queue就自动执行下一个。 然后开始的时候同时调用n次这个函数就好了。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> F = <span class="function">() =&gt;</span> <span class="title class_">Promise</span>&lt;<span class="built_in">any</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">promisePool</span>(<span class="params">functions: F[], n: <span class="built_in">number</span></span>): <span class="title class_">Promise</span>&lt;<span class="built_in">any</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> remaining = [...functions];</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(remaining.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> fn = remaining.<span class="title function_">shift</span>();</span><br><span class="line">            <span class="keyword">await</span> <span class="title function_">fn</span>();</span><br><span class="line">            <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> tasks = functions.<span class="title function_">slice</span>(<span class="number">0</span>, n).<span class="title function_">map</span>(next);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(tasks);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promisePool = <span class="keyword">async</span> <span class="keyword">function</span>(<span class="params">functions, n</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">next</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (functions.<span class="property">length</span>) <span class="keyword">await</span> functions.<span class="title function_">shift</span>()();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>([...<span class="title class_">Array</span>(n)].<span class="title function_">map</span>(next));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promisePool = <span class="keyword">async</span> <span class="keyword">function</span>(<span class="params">functions, n</span>) &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>([...<span class="keyword">new</span> <span class="title class_">Array</span>(n)].<span class="title function_">map</span>(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (functions.<span class="property">length</span>) &#123;</span><br><span class="line">            <span class="keyword">await</span> functions.<span class="title function_">shift</span>()()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;))</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Function[]</span>&#125; <span class="variable">functions</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">Function</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> promisePool = <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params">functions, n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> iter = functions.<span class="title function_">values</span>()</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">worker</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> work <span class="keyword">of</span> iter) &#123;</span><br><span class="line">            <span class="keyword">await</span> <span class="title function_">work</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">allSettled</span>(<span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>().<span class="title function_">map</span>(worker))</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2637-有时间限制的Promise对象"><a href="#2637-有时间限制的Promise对象" class="headerlink" title="2637.有时间限制的Promise对象"></a>2637.有时间限制的Promise对象</h2><p>请你编写一个函数，它接收一个异步函数 <code>fn</code> 和一个以毫秒为单位的时间 <code>t</code>。它应根据限时函数返回一个有 <strong>限时</strong> 效果的函数。</p>
<p>限时函数是与原函数相同的函数，除非它需要 <code>t</code> 毫秒以上的时间来完成。如果出现了这种情况，请你返回 <code>&quot;Time Limit Exceeded&quot;</code> 拒绝这次函数的调用。注意，它应该返回一个字符串拒绝，而不是一个 <code>Error</code> 。</p>
<h3 id="题解-19"><a href="#题解-19" class="headerlink" title="题解"></a>题解</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Fn</span> = <span class="function">(<span class="params">...params: <span class="built_in">any</span>[]</span>) =&gt;</span> <span class="title class_">Promise</span>&lt;<span class="built_in">any</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">timeLimit</span>(<span class="params">fn: Fn, t: <span class="built_in">number</span></span>): <span class="title class_">Fn</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">async</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> timer;</span><br><span class="line">        <span class="keyword">const</span> timeoutPromise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">res,rej</span>) =&gt;</span> &#123;</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">rej</span>(<span class="string">&#x27;Time Limit Exceeded&#x27;</span>), t)</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">race</span>([<span class="title function_">fn</span>(...args),timeoutPromise]).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2648-生成斐波那契数列"><a href="#2648-生成斐波那契数列" class="headerlink" title="2648.生成斐波那契数列"></a>2648.生成斐波那契数列</h2><p>请你编写一个生成器函数，并返回一个可以生成 <strong>斐波那契数列</strong> 的生成器对象。</p>
<p><strong>斐波那契数列</strong> 的递推公式为 <code>Xn = Xn-1 + Xn-2</code> 。</p>
<p>这个数列的前几个数字是 <code>0, 1, 1, 2, 3, 5, 8, 13</code> 。</p>
<h3 id="题解-20"><a href="#题解-20" class="headerlink" title="题解"></a>题解</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">fibGenerator</span>(): <span class="title class_">Generator</span>&lt;<span class="built_in">number</span>, <span class="built_in">any</span>, <span class="built_in">number</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">yield</span> a;</span><br><span class="line">        [a, b] = [b, a + b];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * const gen = fibGenerator();</span></span><br><span class="line"><span class="comment"> * gen.next().value; // 0</span></span><br><span class="line"><span class="comment"> * gen.next().value; // 1</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">fibGenerator</span>(): <span class="title class_">Generator</span>&lt;<span class="built_in">number</span>, <span class="built_in">any</span>, <span class="built_in">number</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> dp = <span class="title class_">Array</span>(<span class="number">51</span>);</span><br><span class="line">  dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= <span class="number">50</span>; i++) &#123;</span><br><span class="line">    dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(dp.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> dp.<span class="title function_">shift</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2649-嵌套数组生成器"><a href="#2649-嵌套数组生成器" class="headerlink" title="2649.嵌套数组生成器"></a>2649.嵌套数组生成器</h2><p>现给定一个整数的 <strong>多维数组</strong> ，请你返回一个生成器对象，按照 <strong>中序遍历</strong> 的顺序逐个生成整数。</p>
<p><strong>多维数组</strong> 是一个递归数据结构，包含整数和其他 <strong>多维数组</strong>。</p>
<p><strong>中序遍历</strong> 是从左到右遍历每个数组，在遇到任何整数时生成它，遇到任何数组时递归应用 <strong>中序遍历</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：arr = [[[6]],[1,3],[]]</span><br><span class="line">输出：[6,1,3]</span><br><span class="line">解释：</span><br><span class="line">const generator = inorderTraversal(arr);</span><br><span class="line">generator.next().value; // 6</span><br><span class="line">generator.next().value; // 1</span><br><span class="line">generator.next().value; // 3</span><br><span class="line">generator.next().done; // true</span><br></pre></td></tr></table></figure>

<h3 id="题解-21"><a href="#题解-21" class="headerlink" title="题解"></a>题解</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MultidimensionalArray</span> = (<span class="title class_">MultidimensionalArray</span> | <span class="built_in">number</span>)[]</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">inorderTraversal</span>(<span class="attr">arr</span>: <span class="title class_">MultidimensionalArray</span>): <span class="title class_">Generator</span>&lt;<span class="built_in">number</span>, <span class="built_in">void</span>, <span class="built_in">unknown</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(item)) &#123;</span><br><span class="line">            <span class="keyword">yield</span>* <span class="title function_">inorderTraversal</span>(item)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">yield</span> item</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * const gen = inorderTraversal([1, [2, 3]]);</span></span><br><span class="line"><span class="comment"> * gen.next().value; // 1</span></span><br><span class="line"><span class="comment"> * gen.next().value; // 2</span></span><br><span class="line"><span class="comment"> * gen.next().value; // 3</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="2650-设计可取消的函数-hard"><a href="#2650-设计可取消的函数-hard" class="headerlink" title="2650.设计可取消的函数(hard)"></a>2650.设计可取消的函数(hard)</h2><p>有时候你会有一个长时间运行的任务，并且你可能希望在它完成之前取消它。为了实现这个目标，请你编写一个名为 <code>cancellable</code> 的函数，它接收一个生成器对象，并返回一个包含两个值的数组：一个 <strong>取消函数</strong> 和一个 <strong>promise</strong> 对象。</p>
<p>你可以假设生成器函数只会生成 promise 对象。你的函数负责将 promise 对象解析的值传回生成器。如果 promise 被拒绝，你的函数应将该错误抛回给生成器。</p>
<p>如果在生成器完成之前调用了取消回调函数，则你的函数应该将错误抛回给生成器。该错误应该是字符串 <code>&quot;Cancelled&quot;</code>（而不是一个 <code>Error</code> 对象）。如果错误被捕获，则返回的 promise 应该解析为下一个生成或返回的值。否则，promise 应该被拒绝并抛出该错误。不应执行任何其他代码。</p>
<p>当生成器完成时，您的函数返回的 promise 应该解析为生成器返回的值。但是，如果生成器抛出错误，则返回的 promise 应该拒绝并抛出该错误。</p>
<p>下面是您的代码应如何使用的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function* tasks() &#123;</span><br><span class="line">  const val = yield new Promise(resolve =&gt; resolve(2 + 2));</span><br><span class="line">  yield new Promise(resolve =&gt; setTimeout(resolve, 100));</span><br><span class="line">  return val + 1; // calculation shouldn&#x27;t be done.</span><br><span class="line">&#125;</span><br><span class="line">const [cancel, promise] = cancellable(tasks());</span><br><span class="line">setTimeout(cancel, 50);</span><br><span class="line">promise.catch(console.log); // logs &quot;Cancelled&quot; at t=50ms</span><br></pre></td></tr></table></figure>

<p>如果相反， <code>cancel()</code> 没有被调用或者在 <code>t=100ms</code> 之后才被调用，那么 Promise 应被解析为 <code>5</code> 。</p>
<h3 id="题解-22"><a href="#题解-22" class="headerlink" title="题解"></a>题解</h3><h4 id="1-什么是-generator-？："><a href="#1-什么是-generator-？：" class="headerlink" title="1.什么是 generator ？："></a>1.什么是 generator ？：</h4><p>简单的说就是可以中断的函数，该函数里的代码可以用 yield 关键字来中断。如何继续执行？看下面</p>
<h4 id="2-怎么定义一个-generator-："><a href="#2-怎么定义一个-generator-：" class="headerlink" title="2.怎么定义一个 generator ："></a>2.怎么定义一个 generator ：</h4><p>一般来说都用 function* 标识符来定义，例如</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">tasks</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> val = <span class="keyword">yield</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="title function_">resolve</span>(<span class="number">2</span> + <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">100</span>));</span><br><span class="line">    <span class="keyword">return</span> val + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-generator-的实例，或者说返回值，有哪些方法？"><a href="#3-generator-的实例，或者说返回值，有哪些方法？" class="headerlink" title="3.generator 的实例，或者说返回值，有哪些方法？"></a>3.generator 的实例，或者说返回值，有哪些方法？</h4><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">tasks</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> val = <span class="keyword">yield</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="title function_">resolve</span>(<span class="number">2</span> + <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">100</span>));</span><br><span class="line">    <span class="keyword">return</span> val + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> _t = <span class="title function_">tasks</span>();</span><br></pre></td></tr></table></figure>

<p>总的来说有三种方法，next、throw, return。这三种方法都会返回一个 IteratorResult，也就是形如：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IteratorResult</span> &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="built_in">any</span>;</span><br><span class="line">    <span class="attr">done</span>: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>done 则表示该 generator 是否完成，true 完成，false 未完成</p>
</li>
<li><p>value 不同方法调用代表的值不同，下面再说。</p>
</li>
</ul>
<p>那么 generator 啥时候完成？就是走到这个 generator 本身 return 的时候。</p>
<p>下面开始介绍三个方法</p>
<ul>
<li><p>next 方法：</p>
<ul>
<li><p>在 next 方法的返回值中，IteratorResult 中的 value 是 yield 关键词右侧代码的执行结果</p>
</li>
<li><p>generator 的执行必需由 next 方法开启，并走到 yield 关键词停止</p>
</li>
<li><p>继续调用next() 可以在 yield 后继续往下走，走到下一个 yield 为止</p>
</li>
<li><p>该方法同时支持传参，传入的参数会成为上一个 yield 的返回值，例如：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">tasks</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> val = <span class="keyword">yield</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="title function_">resolve</span>(<span class="number">2</span> + <span class="number">2</span>)); <span class="comment">// 1</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;val&#125;);</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">100</span>)); <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> val + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> _t = <span class="title function_">tasks</span>();</span><br><span class="line">_t.<span class="title function_">next</span>(); <span class="comment">// 走到 1 处，返回的 &#123;value， done&#125; 中的 value 是 1 处的 Promise</span></span><br><span class="line">_t.<span class="title function_">next</span>(<span class="number">100</span>); <span class="comment">// 走到 2 处，打印 val 为 100</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>throw 方法：</p>
<ul>
<li><p>在 throw 方法的返回值中，IteratorResult 中的 value 同样是 yield 关键词右侧代码的执行结果</p>
</li>
<li><p>该方法通过传参抛出一个错误，如果该错误没有被 generator 本身 catch 住，则会往外暴露给外层，也就是 generator 的调用方。如果调用方也没有 catch 住，则正常抛错。</p>
</li>
<li><p>例子1，被 generator 本身 catch：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">tasks</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> val = <span class="keyword">yield</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="title function_">resolve</span>(<span class="number">2</span> + <span class="number">2</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;catched by generator *tasks&#x27;</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">100</span>));</span><br><span class="line">    <span class="keyword">return</span> val + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> _t = <span class="title function_">tasks</span>();</span><br><span class="line">_t.<span class="title function_">next</span>();</span><br><span class="line">_t.<span class="keyword">throw</span>(<span class="string">&#x27;err 1&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>例子2，被 generator 的调用方 catch：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">tasks</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> val = <span class="keyword">yield</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="title function_">resolve</span>(<span class="number">2</span> + <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">100</span>));</span><br><span class="line">    <span class="keyword">return</span> val + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> _t = <span class="title function_">tasks</span>();</span><br><span class="line">_t.<span class="title function_">next</span>();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    _t.<span class="keyword">throw</span>(<span class="string">&#x27;err 2&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;catched by generator *tasks caller&#x27;</span>, err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>return 方法</p>
<ul>
<li><p>在 return 方法的返回值中，IteratorResult 中的 value 同样是 return 方法传递的参数</p>
</li>
<li><p>该方法强制 generator 函数完成，其返回 IteratorResult 中的 done 将为 true</p>
</li>
<li><p>举例</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">tasks</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> val = <span class="keyword">yield</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="title function_">resolve</span>(<span class="number">2</span> + <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">100</span>));</span><br><span class="line">    <span class="keyword">return</span> val + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> _t = <span class="title function_">tasks</span>();</span><br><span class="line">_t.<span class="title function_">next</span>();</span><br><span class="line"><span class="keyword">const</span> obj = _t.<span class="keyword">return</span>(<span class="string">&#x27;Return by Generator.return method&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj); <span class="comment">// &#123;value: &#x27;Return by Generator.return method&#x27;, done: true&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="4-回到本题"><a href="#4-回到本题" class="headerlink" title="4.回到本题"></a>4.回到本题</h4><ol>
<li>首先得返回一个数组，一个是 function，一个是 Promise</li>
<li>其次我们要走完这个 generator 得不停的调用 next 方法。一般用 while 或者递归，这里我们涉及传参给下一个调用，所以要用递归</li>
<li>我们有个 cancel 方法，根据题意，这个方法显然是要用 throw 方法的，并且其失败被 generator 调用方 捕获时，要直接 reject 这个 Promise。所以要利用闭包定义在 Promise 中</li>
<li>generator 内部调用的 Promise 可能成功也可能失败，所以要处理成功、失败两种情况。对于这个 Promise 来说，成功的回调我们走 next，失败的回调我们应该 throw</li>
<li>generator 本身会抛出一个错误，所以要对 next 的运行进行 try catch，根据题意 catch 后我们要直接 reject 掉这个 Promise</li>
</ol>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> cancellable&lt;T&gt;(<span class="attr">generator</span>: <span class="title class_">Generator</span>&lt;<span class="title class_">Promise</span>&lt;<span class="built_in">any</span>&gt;, T, <span class="built_in">unknown</span>&gt;): [<span class="function">() =&gt;</span> <span class="built_in">void</span>, <span class="title class_">Promise</span>&lt;T&gt;] &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">cancel</span> = (<span class="params"></span>) =&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>&lt;T&gt;(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        cancel = <span class="function">(<span class="params">msg = <span class="string">&#x27;Cancelled&#x27;</span></span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">run</span>(msg, <span class="string">&#x27;throw&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="title function_">run</span> = (<span class="params">ret, fnName = <span class="string">&#x27;next&#x27;</span></span>) =&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> &#123;value, done&#125; = generator[fnName](ret);</span><br><span class="line">                <span class="keyword">if</span>(done) &#123;</span><br><span class="line">                    <span class="title function_">resolve</span>(value);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                value.<span class="title function_">then</span>(<span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="title function_">run</span>(val);</span><br><span class="line">                &#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="title function_">run</span>(err, <span class="string">&#x27;throw&#x27;</span>);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; <span class="keyword">catch</span>(errorByGenerator) &#123;</span><br><span class="line">                <span class="title function_">reject</span>(errorByGenerator);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="title function_">run</span>(<span class="literal">null</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> [cancel, p];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * function* tasks() &#123;</span></span><br><span class="line"><span class="comment"> *   const val = yield new Promise(resolve =&gt; resolve(2 + 2));</span></span><br><span class="line"><span class="comment"> *   yield new Promise(resolve =&gt; setTimeout(resolve, 100));</span></span><br><span class="line"><span class="comment"> *   return val + 1;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * const [cancel, promise] = cancellable(tasks());</span></span><br><span class="line"><span class="comment"> * setTimeout(cancel, 50);</span></span><br><span class="line"><span class="comment"> * promise.catch(console.log); // logs &quot;Cancelled&quot; at t=50ms</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="2665-计数器II"><a href="#2665-计数器II" class="headerlink" title="2665.计数器II"></a>2665.计数器II</h2><p>请你写一个函数 <code>createCounter</code>. 这个函数接收一个初始的整数值 <code>init</code> 并返回一个包含三个函数的对象。</p>
<p>这三个函数是：</p>
<ul>
<li><code>increment()</code> 将当前值加 1 并返回。</li>
<li><code>decrement()</code> 将当前值减 1 并返回。</li>
<li><code>reset()</code> 将当前值设置为 <code>init</code> 并返回。</li>
</ul>
<h3 id="题解-23"><a href="#题解-23" class="headerlink" title="题解"></a>题解</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ReturnObj</span> = &#123;</span><br><span class="line">    <span class="attr">increment</span>: <span class="function">() =&gt;</span> <span class="built_in">number</span>,</span><br><span class="line">    <span class="attr">decrement</span>: <span class="function">() =&gt;</span> <span class="built_in">number</span>,</span><br><span class="line">    <span class="attr">reset</span>: <span class="function">() =&gt;</span> <span class="built_in">number</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createCounter</span>(<span class="params">init: <span class="built_in">number</span></span>): <span class="title class_">ReturnObj</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> n = init;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; ++n;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">reset</span> = (<span class="params"></span>) =&gt; n = init;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">decrement</span> = (<span class="params"></span>) =&gt; --n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;increment, decrement, reset&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * const counter = createCounter(5)</span></span><br><span class="line"><span class="comment"> * counter.increment(); // 6</span></span><br><span class="line"><span class="comment"> * counter.reset(); // 5</span></span><br><span class="line"><span class="comment"> * counter.decrement(); // 4</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h3><blockquote>
<p>const reset &#x3D; () &#x3D;&gt; n &#x3D; init;</p>
</blockquote>
<p>是可以直接n同时赋值并返回的。</p>
<h2 id="2666-只允许一次函数调用"><a href="#2666-只允许一次函数调用" class="headerlink" title="2666.只允许一次函数调用"></a>2666.只允许一次函数调用</h2><p>给定一个函数 <code>fn</code> ，它返回一个新的函数，返回的函数与原始函数完全相同，只不过它确保 <code>fn</code> 最多被调用一次。</p>
<ul>
<li>第一次调用返回的函数时，它应该返回与 <code>fn</code> 相同的结果。</li>
<li>第一次后的每次调用，它应该返回 <code>undefined</code> 。</li>
</ul>
<h3 id="题解-24"><a href="#题解-24" class="headerlink" title="题解"></a>题解</h3><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> once&lt;T <span class="keyword">extends</span> (...<span class="attr">args</span>: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span>&gt;(<span class="attr">fn</span>: T): </span><br><span class="line"> (<span class="function">(<span class="params">...args: Parameters&lt;T&gt;</span>) =&gt;</span> <span class="title class_">ReturnType</span>&lt;T&gt; | <span class="literal">undefined</span>) &#123;</span><br><span class="line">     <span class="keyword">let</span> hasUsed = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(hasUsed) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">          hasUsed = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, [...args])</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * let fn = (a,b,c) =&gt; (a + b + c)</span></span><br><span class="line"><span class="comment"> * let onceFn = once(fn)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * onceFn(1,2,3); // 6</span></span><br><span class="line"><span class="comment"> * onceFn(2,3,6); // returns undefined without calling fn</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h4 id="try…catch"><a href="#try…catch" class="headerlink" title="try…catch"></a>try…catch</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//finally的内容会在return后执行，在finally里面把fn换成空函数就可以了</span></span><br><span class="line"><span class="keyword">var</span> once = <span class="keyword">function</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">fn</span>(...args)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span>&#123;</span><br><span class="line">            fn=<span class="function">()=&gt;</span>&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="注意-3"><a href="#注意-3" class="headerlink" title="注意"></a>注意</h3><p>以下是对代码中 TypeScript 部分的解释：</p>
<ul>
<li><code>function once&lt;T extends (...args: any[]) =&gt; any&gt;(fn: T): ...</code>：这是 <code>once</code> 函数的定义。它使用了 TypeScript 的泛型 <code>&lt;T&gt;</code> 来表示函数的类型，并限制泛型类型 <code>T</code> 必须是一个函数类型，可以接受任意数量的参数并返回一个值。</li>
<li><code>(...args: Parameters&lt;T&gt;) =&gt; ReturnType&lt;T&gt; | undefined</code>：这是返回函数的类型定义。它使用了 TypeScript 的内置类型 <code>Parameters&lt;T&gt;</code> 来获取函数类型 <code>T</code> 的参数类型，并使用 <code>ReturnType&lt;T&gt;</code> 获取函数类型 <code>T</code> 的返回值类型。返回函数接受与 <code>fn</code> 相同的参数，并返回 <code>fn</code> 的返回值或 <code>undefined</code>。</li>
<li><code>return function (...args) &#123; ... &#125;</code>：这是返回函数的实现部分。返回的函数使用了剩余参数 <code>...args</code> 来接收任意数量的参数。在函数体内部，可以根据需要实现具体的逻辑。</li>
</ul>
<h2 id="2675-将对象数组转换为矩阵"><a href="#2675-将对象数组转换为矩阵" class="headerlink" title="2675.将对象数组转换为矩阵"></a>2675.将对象数组转换为矩阵</h2><p>编写一个函数，将对象数组 <code>arr</code> 转换为矩阵 <code>m</code> 。</p>
<p><code>arr</code> 是一个由对象组成的数组或一个数组。数组中的每个项都可以包含深层嵌套的子数组和子对象。它还可以包含数字、字符串、布尔值和空值。</p>
<p>矩阵 <code>m</code> 的第一行应该是列名。如果没有嵌套，列名是对象中的唯一键。如果存在嵌套，列名是对象中相应路径，以点号 <code>&quot;.&quot;</code> 分隔。</p>
<p>剩余的每一行对应 <code>arr</code> 中的一个对象。矩阵中的每个值对应对象中的一个值。如果给定对象在给定列中没有值，则应该包含空字符串 <code>&quot;&quot;</code> 。</p>
<p>矩阵中的列应按 <strong>字典升序</strong> 排列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">arr = [</span><br><span class="line">  &#123;&quot;b&quot;: 1, &quot;a&quot;: 2&#125;,</span><br><span class="line">  &#123;&quot;b&quot;: 3, &quot;a&quot;: 4&#125;</span><br><span class="line">]</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [&quot;a&quot;, &quot;b&quot;],</span><br><span class="line">  [2, 1],</span><br><span class="line">  [4, 3]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">两个对象中有两个唯一的列名：&quot;a&quot;和&quot;b&quot;。 </span><br><span class="line">&quot;a&quot;对应[2, 4]。 </span><br><span class="line">&quot;b&quot;对应[1, 3]。</span><br></pre></td></tr></table></figure>

<h3 id="题解-25"><a href="#题解-25" class="headerlink" title="题解"></a>题解</h3><h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><ul>
<li>Object.keys() 对对象操作，获得的是该对象的键数组。</li>
<li>Object.keys() 对数组操作，获得的是该数组的下标数组。</li>
</ul>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>首先需要递归地处理所有的Key，包括数组和对象的。将其存放到一个Map中，该Map负责将Key映射到下标。之后再递归地处理相应的值。</p>
<p><strong>1.处理Key（第一次递归）</strong></p>
<p>因为有对象嵌套对象，所以需要递归地处理。</p>
<p>o：当前遍历的对象（数组）；<br>prefix：key的前缀字符串。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">resolveHead</span>(<span class="params">o, prefix</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> k <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(o)) &#123;</span><br><span class="line">        <span class="comment">// 如果是可枚举类型就继续递归</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> o[k] === <span class="string">&quot;object&quot;</span> &amp;&amp; o[k] !== <span class="literal">null</span>)</span><br><span class="line">            <span class="title function_">resolveHead</span>(o[k], prefix + k + <span class="string">&quot;.&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            set.<span class="title function_">add</span>(prefix + k)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">o</span>) =&gt;</span> <span class="title function_">resolveHead</span>(o, <span class="string">&quot;&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>经过这一步递归处理，在set已经存放了所有的可能出现的键了。</p>
<p><strong>2.将set转换成map</strong><br>我们需要将键映射到下标，且set本身并不一定按字典升序排列，所以需要先排序，再存放到map中。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> titles = <span class="title class_">Array</span>.<span class="title function_">from</span>(set).<span class="title function_">sort</span>()</span><br><span class="line">result.<span class="title function_">push</span>(titles) <span class="comment">// 将其存放到第一行</span></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">titles.<span class="title function_">forEach</span>(<span class="function">(<span class="params">v, i</span>) =&gt;</span> map.<span class="title function_">set</span>(v, i))</span><br></pre></td></tr></table></figure>

<p><strong>3.处理每一行的结果（第二次递归）</strong></p>
<p>这个步骤逻辑几乎和第一遍处理key一样，只需要多传递一个row，以及将set.add(prefix + k)换成修改row中的元素即可。</p>
<p>o：当前遍历的对象（数组）；<br>prefix：key的前缀字符串；<br>row：当前处理的行。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">resolveRow</span>(<span class="params">o, prefix, row</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> k <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(o)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> o[k] === <span class="string">&quot;object&quot;</span> &amp;&amp; o[k] !== <span class="literal">null</span>)</span><br><span class="line">            <span class="title function_">resolveRow</span>(o[k], prefix + k + <span class="string">&quot;.&quot;</span>, row)</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            row[map.<span class="title function_">get</span>(prefix + k)] = o[k]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">o</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> row = <span class="keyword">new</span> <span class="title class_">Array</span>(map.<span class="property">size</span>).<span class="title function_">fill</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="title function_">resolveRow</span>(o, <span class="string">&quot;&quot;</span>, row)</span><br><span class="line">    result.<span class="title function_">push</span>(row)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>完整代码</strong></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Item</span> = (<span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span> | <span class="literal">null</span>)[]</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">jsonToMatrix</span>(<span class="params">arr: <span class="built_in">any</span>[]</span>): <span class="title class_">Item</span>[] &#123;</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">getEveryKey</span>(<span class="params">o: <span class="built_in">object</span>, prefix: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> k <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(o)) &#123;</span><br><span class="line">            <span class="comment">// 如果是可枚举类型则继续递归</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">typeof</span> o[k] === <span class="string">&quot;object&quot;</span> &amp;&amp; o[k] !== <span class="literal">null</span>)</span><br><span class="line">                <span class="title function_">getEveryKey</span>(o[k], prefix + k + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                set.<span class="title function_">add</span>(prefix + k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成所有key</span></span><br><span class="line">    arr.<span class="title function_">forEach</span>(<span class="function"><span class="params">o</span> =&gt;</span> <span class="title function_">getEveryKey</span>(o, <span class="string">&quot;&quot;</span>))</span><br><span class="line">    <span class="comment">// 默认将元素转换为字符串，根据unicode码排序 eg: (b,c,a) =&gt; (a,b,c)</span></span><br><span class="line">    <span class="keyword">const</span> titles = <span class="title class_">Array</span>.<span class="title function_">from</span>(set).<span class="title function_">sort</span>();</span><br><span class="line">    result.<span class="title function_">push</span>(titles);</span><br><span class="line">    <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>&lt;<span class="built_in">string</span>, <span class="built_in">number</span>&gt;();</span><br><span class="line">    titles.<span class="title function_">forEach</span>(<span class="function">(<span class="params">v, i</span>) =&gt;</span> map.<span class="title function_">set</span>(v, i))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">resolveRow</span>(<span class="params">o:<span class="built_in">object</span>, prefix:<span class="built_in">string</span>, row:Item</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> k <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(o)) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">typeof</span> o[k] === <span class="string">&quot;object&quot;</span> &amp;&amp; o[k] !== <span class="literal">null</span>)</span><br><span class="line">                <span class="title function_">resolveRow</span>(o[k], prefix + k + <span class="string">&quot;.&quot;</span>, row);</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                row[map.<span class="title function_">get</span>(prefix + k)] = o[k]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    arr.<span class="title function_">forEach</span>(<span class="function"><span class="params">o</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="attr">row</span>: <span class="title class_">Item</span> = <span class="keyword">new</span> <span class="title class_">Array</span>(map.<span class="property">size</span>).<span class="title function_">fill</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="title function_">resolveRow</span>(o, <span class="string">&quot;&quot;</span>, row);</span><br><span class="line">        result.<span class="title function_">push</span>(row);</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2693-使用自定义上下文调用函数"><a href="#2693-使用自定义上下文调用函数" class="headerlink" title="2693.使用自定义上下文调用函数"></a>2693.使用自定义上下文调用函数</h2><p>增强所有函数，使其具有 <code>callPolyfill</code> 方法。该方法接受一个对象 <code>obj</code> 作为第一个参数，以及任意数量的附加参数。<code>obj</code> 成为函数的 <code>this</code> 上下文。附加参数将传递给该函数（即 <code>callPolyfill</code> 方法所属的函数）。</p>
<p>例如，如果有以下函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function tax(price, taxRate) &#123;</span><br><span class="line">  const totalCost = price * (1 + taxRate);</span><br><span class="line">  console.log(`The cost of $&#123;this.item&#125; is $&#123;totalCost&#125;`);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 <code>tax(10, 0.1)</code> 将输出 <code>&quot;The cost of undefined is 11&quot;</code> 。这是因为 <code>this</code> 上下文未定义。</p>
<p>然而，调用 <code>tax.callPolyfill(&#123;item: &quot;salad&quot;&#125;, 10, 0.1)</code> 将输出 <code>&quot;The cost of salad is 11&quot;</code> 。<code>this</code> 上下文被正确设置，函数输出了适当的结果。</p>
<p>请在不使用内置的 <code>Function.call</code> 方法的情况下解决这个问题。</p>
<blockquote>
<p>实际上就是手写一个function.call()函数</p>
</blockquote>
<h3 id="题解-26"><a href="#题解-26" class="headerlink" title="题解"></a>题解</h3><h4 id="方法一-经典写法"><a href="#方法一-经典写法" class="headerlink" title="方法一 经典写法"></a>方法一 经典写法</h4><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable language_">global</span> &#123; </span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Function</span> &#123;</span><br><span class="line">      <span class="title function_">callPolyfill</span>(<span class="attr">context</span>: <span class="title class_">Record</span>&lt;<span class="built_in">any</span>, <span class="built_in">any</span>&gt;, ...<span class="attr">args</span>: <span class="built_in">any</span>[]): <span class="built_in">any</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">callPolyfill</span> = <span class="keyword">function</span>(<span class="params">context, ...args</span>): <span class="built_in">any</span> &#123;</span><br><span class="line">    context ||= <span class="variable language_">window</span>;</span><br><span class="line">    context.<span class="property">fn</span> = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">const</span> result = context.<span class="title function_">fn</span>(...args);</span><br><span class="line">    <span class="keyword">delete</span> context.<span class="property">fn</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法通不过测试用例<code>function keys() &#123; return Object.keys(this); &#125;</code>。</p>
<h4 id="方法二-使用Symbol来解决Object-keys-this-问题"><a href="#方法二-使用Symbol来解决Object-keys-this-问题" class="headerlink" title="方法二 使用Symbol来解决Object.keys(this)问题"></a>方法二 使用Symbol来解决Object.keys(this)问题</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Object</span>&#125; <span class="variable">context</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">any[]</span>&#125; <span class="variable">args</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">any</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">callPolyfill</span> = <span class="keyword">function</span>(<span class="params">context, ...args</span>) &#123;</span><br><span class="line">  context ||= <span class="variable language_">window</span>;</span><br><span class="line">  <span class="keyword">const</span> key = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="variable language_">this</span>);</span><br><span class="line">  context[key] = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">const</span> result = context[key](...args);</span><br><span class="line">  <span class="keyword">delete</span> context[key];</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在js中，使用 Symbol 作为对象的属性名时，它是一个独一无二的值，不会被遍历或显示出来。因此，当使用 <code>Object.keys()</code> 或 <code>for...in</code> 循环遍历对象属性时，不会包括使用 Symbol 作为属性名的属性。</p>
<p>但是， <strong>TypeScript 不允许使用唯一符号（unique symbol）作为索引类型导致的。</strong></p>
<blockquote>
<p>TypeScript 的类型系统在编译时会执行静态类型检查，以确保代码的类型安全性。由于 <code>symbol</code> 无法被索引，因此在类型检查期间无法准确推断 <code>symbol</code> 作为键名的属性类型。</p>
<p>为了确保类型安全和一致性，TypeScript 限制了使用 <code>symbol</code> 作为键名的能力。这样可以防止在编译时出现潜在的错误，并促使开发者使用其他可索引的键类型，如字符串或数字，来定义对象的属性。</p>
</blockquote>
<h4 id="方法三-使用Object-defineProperty来解决Object-keys-this-问题"><a href="#方法三-使用Object-defineProperty来解决Object-keys-this-问题" class="headerlink" title="方法三 使用Object.defineProperty来解决Object.keys(this)问题"></a>方法三 使用Object.defineProperty来解决Object.keys(this)问题</h4><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable language_">global</span> &#123; </span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Function</span> &#123;</span><br><span class="line">      <span class="title function_">callPolyfill</span>(<span class="attr">context</span>: <span class="title class_">Record</span>&lt;<span class="built_in">any</span>, <span class="built_in">any</span>&gt;, ...<span class="attr">args</span>: <span class="built_in">any</span>[]): <span class="built_in">any</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">callPolyfill</span> = <span class="keyword">function</span>(<span class="params">context, ...args</span>): <span class="built_in">any</span> &#123;</span><br><span class="line">    context ||= <span class="variable language_">window</span>;</span><br><span class="line">    <span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(context, <span class="string">&quot;fn&quot;</span>, &#123;</span><br><span class="line">        <span class="attr">enumerable</span>:<span class="literal">false</span>,</span><br><span class="line">        <span class="attr">writable</span>:<span class="literal">false</span>,</span><br><span class="line">        <span class="attr">value</span>:<span class="variable language_">this</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">const</span> result = context.<span class="title function_">fn</span>(...args);</span><br><span class="line">    <span class="keyword">delete</span> context.<span class="property">fn</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Reflect-defineProperty-和-Object-defineProperty"><a href="#Reflect-defineProperty-和-Object-defineProperty" class="headerlink" title="Reflect.defineProperty 和 Object.defineProperty"></a><code>Reflect.defineProperty</code> 和 <code>Object.defineProperty</code></h4><blockquote>
<p><code>Reflect.defineProperty</code> 和 <code>Object.defineProperty</code> 都是用于定义对象属性的方法，它们具有类似的功能，但在一些细节上有所不同。</p>
<p><code>Object.defineProperty</code> 是 ES5 中引入的方法，而 <code>Reflect.defineProperty</code> 是在 ES6 中添加到 <code>Reflect</code> 对象上的方法。它们的作用是在一个对象上定义一个新的属性或修改现有属性的特性。</p>
<p>下面是它们之间的一些区别：</p>
<ol>
<li>返回值:<ul>
<li><code>Object.defineProperty</code> 返回被操作的对象。</li>
<li><code>Reflect.defineProperty</code> 返回一个布尔值，表示属性是否定义成功。</li>
</ul>
</li>
<li>错误处理：<ul>
<li><code>Object.defineProperty</code> 会抛出异常（TypeError）来表示定义属性时的错误，例如不可配置的属性不允许重新定义等。</li>
<li><code>Reflect.defineProperty</code> 在失败时不会抛出异常，而是返回 <code>false</code>。</li>
</ul>
</li>
<li>参数顺序：<ul>
<li><code>Object.defineProperty</code> 的参数顺序为：<code>Object.defineProperty(obj, prop, descriptor)</code></li>
<li><code>Reflect.defineProperty</code> 的参数顺序为：<code>Reflect.defineProperty(obj, prop, descriptor)</code></li>
</ul>
</li>
</ol>
<p>总体而言，<code>Reflect.defineProperty</code> 提供了一种更统一和一致的方式来定义和操作对象的属性，而且在一些特殊情况下，它比 <code>Object.defineProperty</code> 更加灵活和方便。然而，在大多数情况下，它们的用法和效果是相似的，选择使用哪个方法主要取决于个人偏好和项目需求。</p>
</blockquote>
<h4 id="方法四-使用原型链"><a href="#方法四-使用原型链" class="headerlink" title="方法四 使用原型链"></a>方法四 使用原型链</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 原型链来解决Object.keys(this)问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">callPolyfill</span> = <span class="keyword">function</span> (<span class="params">context, ...args</span>) &#123;</span><br><span class="line">  context ||= <span class="variable language_">window</span>;</span><br><span class="line">  context.<span class="property">__proto__</span>.<span class="property">fn</span> = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">const</span> result = context.<span class="title function_">fn</span>(...args);</span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">__proto__</span>.<span class="property">fn</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="方法五-使用proxy代理"><a href="#方法五-使用proxy代理" class="headerlink" title="方法五 使用proxy代理"></a>方法五 使用proxy代理</h4><p>通过使用 <code>Proxy</code> 对象，创建了一个代理对象 <code>proxy</code>，用于拦截对 <code>context</code> 的属性访问。在访问属性时，如果属性名为 “fn”，则返回保存的函数 <code>fn</code>；否则，使用 <code>Reflect.get</code> 方法来获取实际属性值。</p>
<p>在这个实现中，通过代理对象 <code>proxy</code>，我们在访问属性时拦截了对 <code>context</code> 对象的访问。当访问属性名为 “fn” 时，代理对象返回的是保存的函数 <code>fn</code>；对于其他属性名，则通过 <code>Reflect.get</code> 方法从实际的 <code>context</code> 对象中获取属性值。</p>
<p>实际上，<code>context</code> 对象本身并没有名为 “fn” 的属性。代理对象只是在访问属性时拦截并返回了一个特定的值。这样做的目的是为了模拟函数调用时的行为，让我们可以在指定的上下文中调用函数，并传入相应的参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * proxy代理来解决Object.keys(this)问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">callPolyfill</span> = <span class="keyword">function</span> (<span class="params">context, ...args</span>) &#123;</span><br><span class="line">  context ||= <span class="variable language_">window</span>;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(context, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, prop</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (prop === <span class="string">&quot;fn&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> fn;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> proxy[<span class="string">&quot;fn&quot;</span>](...args);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2696-事件发射器"><a href="#2696-事件发射器" class="headerlink" title="2696.事件发射器"></a>2696.事件发射器</h2><p>设计一个 <code>EventEmitter</code> 类。这个接口与 Node.js 或 DOM 的 Event Target 接口相似，但有一些差异。<code>EventEmitter</code> 应该允许订阅事件和触发事件。</p>
<p>你的 <code>EventEmitter</code> 类应该有以下两个方法：</p>
<ul>
<li><strong>subscribe</strong> - 这个方法接收两个参数：一个作为字符串的事件名和一个回调函数。当事件被触发时，这个回调函数将被调用。 一个事件应该能够有多个监听器。当触发带有多个回调函数的事件时，应按照订阅的顺序依次调用每个回调函数。应返回一个结果数组。你可以假设传递给 <code>subscribe</code> 的回调函数都不是引用相同的。 <code>subscribe</code> 方法还应返回一个对象，其中包含一个 <code>unsubscribe</code> 方法，使用户可以取消订阅。当调用 <code>unsubscribe</code> 方法时，回调函数应该从订阅列表中删除，并返回 undefined。</li>
<li><strong>emit</strong> - 这个方法接收两个参数：一个作为字符串的事件名和一个可选的参数数组，这些参数将传递给回调函数。如果没有订阅给定事件的回调函数，则返回一个空数组。否则，按照它们被订阅的顺序返回所有回调函数调用的结果数组。</li>
</ul>
<h3 id="题解-27"><a href="#题解-27" class="headerlink" title="题解"></a>题解</h3><h4 id="方法一-用map来保存事件和回调函数的映射"><a href="#方法一-用map来保存事件和回调函数的映射" class="headerlink" title="方法一 用map来保存事件和回调函数的映射"></a>方法一 用map来保存事件和回调函数的映射</h4><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Callback</span> = <span class="function">(<span class="params">...args: <span class="built_in">any</span>[]</span>) =&gt;</span> <span class="built_in">any</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Subscription</span> = &#123;</span><br><span class="line">    <span class="attr">unsubscribe</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventEmitter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>&lt;<span class="built_in">string</span>, <span class="title class_">Callback</span>[]&gt;();</span><br><span class="line">  <span class="title function_">subscribe</span>(<span class="attr">eventName</span>: <span class="built_in">string</span>, <span class="attr">callback</span>: <span class="title class_">Callback</span>): <span class="title class_">Subscription</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">has</span>(eventName)) <span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">set</span>(eventName, []);</span><br><span class="line">    <span class="keyword">const</span> callbacks = <span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">get</span>(eventName);</span><br><span class="line">    callbacks.<span class="title function_">push</span>(callback);</span><br><span class="line">    <span class="keyword">const</span> index = callbacks.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">unsubscribe</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          callbacks.<span class="title function_">splice</span>(index, <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">emit</span>(<span class="attr">eventName</span>: <span class="built_in">string</span>, <span class="attr">args</span>: <span class="built_in">any</span>[] = []): <span class="built_in">any</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> callbacks = <span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">get</span>(eventName) || [];</span><br><span class="line">      <span class="keyword">return</span> callbacks.<span class="title function_">map</span>(<span class="function"><span class="params">callback</span> =&gt;</span> <span class="title function_">callback</span>(...args))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * const emitter = new EventEmitter();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * // Subscribe to the onClick event with onClickCallback</span></span><br><span class="line"><span class="comment"> * function onClickCallback() &#123; return 99 &#125;</span></span><br><span class="line"><span class="comment"> * const sub = emitter.subscribe(&#x27;onClick&#x27;, onClickCallback);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * emitter.emit(&#x27;onClick&#x27;); // [99]</span></span><br><span class="line"><span class="comment"> * sub.unsubscribe(); // undefined</span></span><br><span class="line"><span class="comment"> * emitter.emit(&#x27;onClick&#x27;); // []</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h4 id="方法二-用Record"><a href="#方法二-用Record" class="headerlink" title="方法二 用Record"></a>方法二 用Record</h4><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Callback</span> = <span class="function">(<span class="params">...args: <span class="built_in">unknown</span>[]</span>) =&gt;</span> <span class="built_in">unknown</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Subscription</span> = &#123;</span><br><span class="line">  <span class="attr">unsubscribe</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventEmitter</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="attr">_events</span>: <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="title class_">Callback</span>[]&gt; = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">subscribe</span>(<span class="attr">eventName</span>: <span class="built_in">string</span>, <span class="attr">callback</span>: <span class="title class_">Callback</span>): <span class="title class_">Subscription</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">_events</span>[eventName]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_events</span>[eventName] = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_events</span>[eventName].<span class="title function_">push</span>(callback)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">unsubscribe</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_events</span>[eventName] = <span class="variable language_">this</span>.<span class="property">_events</span>[eventName].<span class="title function_">filter</span>(<span class="function"><span class="params">cb</span> =&gt;</span> cb !== callback)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">emit</span>(<span class="attr">eventName</span>: <span class="built_in">string</span>, <span class="attr">args</span>: <span class="built_in">unknown</span>[] = []): <span class="built_in">unknown</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> callbacks = <span class="variable language_">this</span>.<span class="property">_events</span>[eventName] || []</span><br><span class="line">    <span class="keyword">return</span> callbacks.<span class="title function_">map</span>(<span class="function"><span class="params">cb</span> =&gt;</span> <span class="title function_">cb</span>(...args))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2695-包装数组"><a href="#2695-包装数组" class="headerlink" title="2695.包装数组"></a>2695.包装数组</h2><p>创建一个名为 <code>ArrayWrapper</code> 的类，它在其构造函数中接受一个整数数组作为参数。该类应具有以下两个特性：</p>
<ul>
<li>当使用 <code>+</code> 运算符将两个该类的实例相加时，结果值为两个数组中所有元素的总和。</li>
<li>当在实例上调用 <code>String()</code> 函数时，它将返回一个由逗号分隔的括在方括号中的字符串。例如，<code>[1,2,3]</code> 。</li>
</ul>
<h3 id="题解-28"><a href="#题解-28" class="headerlink" title="题解"></a>题解</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayWrapper</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> arr = [];</span><br><span class="line">	<span class="title function_">constructor</span>(<span class="params">nums: <span class="built_in">number</span>[]</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">getElement</span>(nums)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> getElement = <span class="function">(<span class="params">argsNums</span>) =&gt;</span> &#123;</span><br><span class="line">        argsNums.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(item)) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="title function_">getElement</span>(item);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">arr</span>.<span class="title function_">push</span>(item);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="title function_">valueOf</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">arr</span>.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, next</span>) =&gt;</span> prev + next, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// return `[$&#123;this.arr.toString()&#125;]`</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">`[<span class="subst">$&#123;[...<span class="variable language_">this</span>.arr]&#125;</span>]`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * const obj1 = new ArrayWrapper([1,2]);</span></span><br><span class="line"><span class="comment"> * const obj2 = new ArrayWrapper([3,4]);</span></span><br><span class="line"><span class="comment"> * obj1 + obj2; // 10</span></span><br><span class="line"><span class="comment"> * String(obj1); // &quot;[1,2]&quot;</span></span><br><span class="line"><span class="comment"> * String(obj2); // &quot;[3,4]&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="2703-返回传递的参数的长度"><a href="#2703-返回传递的参数的长度" class="headerlink" title="2703.返回传递的参数的长度"></a>2703.返回传递的参数的长度</h2><p>请你编写一个函数 <code>argumentsLength</code>，返回传递给该函数的参数数量。</p>
<h3 id="题解-29"><a href="#题解-29" class="headerlink" title="题解"></a>题解</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">argumentsLength</span>(<span class="params">...args: <span class="built_in">any</span>[]</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> [...args].<span class="property">length</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * argumentsLength(1, 2, 3); // 3</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>arguments</code> 是一个类数组对象，包含函数调用时传递给函数的所有参数。它是一个特殊的对象，在函数内部自动创建并可用于访问所有传入的参数，无需事先定义函数参数。</p>
<p><code>...args</code> 是剩余参数（Rest Parameters）语法，它允许将函数的多个参数收集到一个数组中。它使用三个点（…）作为前缀，后面跟着一个数组名（args）。在函数声明或函数表达式中，它用于指定函数的最后一个参数可以接受多个参数值，并将这些值收集到一个数组中。</p>
<p>主要区别如下：</p>
<ul>
<li><code>arguments</code> 是一个类数组对象，可以在函数内部访问所有传入的参数，包括未在函数签名中声明的参数。它不是一个真正的数组，因此无法使用数组方法和属性。</li>
<li><code>...args</code> 是用于声明函数的剩余参数的语法。它将传递给函数的多个参数收集到一个真正的数组中，可以使用数组方法和属性对其进行操作。</li>
</ul>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">javascriptCopy code<span class="keyword">function</span> <span class="title function_">example</span>(<span class="params">a, b, ...args</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 输出第一个参数</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// 输出第二个参数</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(args); <span class="comment">// 输出剩余的参数数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">example</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// [3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<p>注意：使用剩余参数语法 <code>...args</code> 可以更方便地处理可变数量的参数，而不必依赖于 <code>arguments</code> 对象。此外，<code>arguments</code> 对象在箭头函数中是不可用的，而剩余参数语法可以在箭头函数中使用。</p>
</blockquote>
<h2 id="2704-相等还是不相等"><a href="#2704-相等还是不相等" class="headerlink" title="2704.相等还是不相等"></a>2704.相等还是不相等</h2><p>请你编写一个名为 <code>expect</code> 的函数，用于帮助开发人员测试他们的代码。它应该接受任何值 <code>val</code> 并返回一个包含以下两个函数的对象。</p>
<ul>
<li><code>toBe(val)</code> 接受另一个值并在两个值相等（ <code>===</code> ）时返回 <code>true</code> 。如果它们不相等，则应抛出错误 <code>&quot;Not Equal&quot;</code> 。</li>
<li><code>notToBe(val)</code> 接受另一个值并在两个值不相等（ <code>!==</code> ）时返回 <code>true</code> 。如果它们相等，则应抛出错误 <code>&quot;Equal&quot;</code> 。</li>
</ul>
<h3 id="题解-30"><a href="#题解-30" class="headerlink" title="题解"></a>题解</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ToBeOrNotToBe</span> = &#123;</span><br><span class="line">    <span class="attr">toBe</span>: <span class="function">(<span class="params">val: <span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="attr">notToBe</span>: <span class="function">(<span class="params">val: <span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">boolean</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">expect</span>(<span class="params">val: <span class="built_in">any</span></span>): <span class="title class_">ToBeOrNotToBe</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">toBe</span>: <span class="function">(<span class="params">matchVal: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(val === matchVal) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Not Equal&quot;</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">notToBe</span>:<span class="function">(<span class="params">matchVal: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(val !== matchVal) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Equal&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * expect(5).toBe(5); // true</span></span><br><span class="line"><span class="comment"> * expect(5).notToBe(5); // throws &quot;Equal&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="2705-精简对象"><a href="#2705-精简对象" class="headerlink" title="2705.精简对象"></a>2705.精简对象</h2><p>现给定一个对象或数组 <code>obj</code>，返回一个 <strong>精简对象</strong> 。<strong>精简对象</strong> 与原始对象相同，只是将包含 <strong>假</strong> 值的键移除。该操作适用于对象及其嵌套对象。数组被视为索引作为键的对象。当 <code>Boolean(value)</code> 返回 <code>false</code> 时，值被视为 <strong>假</strong> 值。</p>
<p>你可以假设 <code>obj</code> 是 <code>JSON.parse</code> 的输出结果。换句话说，它是有效的 JSON。</p>
<h3 id="题解-31"><a href="#题解-31" class="headerlink" title="题解"></a>题解</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Obj</span> = <span class="title class_">Record</span>&lt;<span class="built_in">any</span>, <span class="built_in">any</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">compactObject</span>(<span class="params">obj: Obj</span>): <span class="title class_">Obj</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(obj === <span class="literal">null</span> || <span class="keyword">typeof</span> obj !== <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj)) &#123;</span><br><span class="line">        <span class="keyword">const</span> res = [];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> obj) &#123;</span><br><span class="line">            <span class="keyword">const</span> val = <span class="title function_">compactObject</span>(item);</span><br><span class="line">            <span class="keyword">if</span>(val) res.<span class="title function_">push</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> res = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)) &#123;</span><br><span class="line">        <span class="keyword">const</span> o = <span class="title function_">compactObject</span>(obj[key]);</span><br><span class="line">        <span class="keyword">if</span>(o) res[key] = o; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>手写</category>
      </categories>
      <tags>
        <tag>手写题</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>token无感刷新</title>
    <url>/2022/09/01/token%E6%97%A0%E6%84%9F%E5%88%B7%E6%96%B0/</url>
    <content><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>开发合同管理系统时，要求用户前端登录后，后端提供一个 token 和 token 的有效时间，当 token 过期时要求使用旧 token 获取新 token，前端无痛刷新 token。</p>
<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ul>
<li>后端返回的 token 和 token 有效时间存储在 localStorage 中；</li>
<li>其中 token 有效时间是一个时间段，而不能是服务器的绝对时间，因为服务器绝对时间可能与前段时间存在出入；</li>
<li>用户登录后发起一个请求时，首先判断 token 是否过期，如果已过期则先调用 refresh-token 方法，更新 token 后再发送请求；</li>
<li>在向后端请求新 token 的时间段内如果有新的请求，则缓存这个时间段内的请求，等待刷新 token 后<strong>按序发送</strong>。</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote>
<p>如果请求拦截器返回了一个 <code>undefined</code>、<code>null</code> 或者没有返回任何值，那么请求就会被拦截并停止发送。如果请求拦截器返回了一个新的 <code>config</code> 对象，则请求将使用这个新的 <code>config</code> 对象进行发送。如果请求拦截器返回了一个 <code>Promise</code> 对象，那么请求会在该 <code>Promise</code> 对象 resolve 后才会继续进行。如果请求拦截器抛出了一个错误或返回了一个 rejected 的 <code>Promise</code> 对象，则请求会被停止并且会进入 axios 的 error 处理流程。</p>
</blockquote>
<p>在 axios 的请求拦截器中判断 token 是否有效。若有效则继续发送请求；否则刷新 token 后重试。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="1-发送请求前，对请求的配置进行拦截处理"><a href="#1-发送请求前，对请求的配置进行拦截处理" class="headerlink" title="1. 发送请求前，对请求的配置进行拦截处理"></a>1. 发送请求前，对请求的配置进行拦截处理</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求前先进行拦截</span></span><br><span class="line">instance.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//这里不单单是获取到token，还要一个token的过期时间，用来进行下面的判断</span></span><br><span class="line">    <span class="keyword">const</span> tokenInfo = <span class="title function_">getToken</span>();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里模拟一下tokenInfo的结构</span></span><br><span class="line"><span class="comment">     * tokenInfo：&#123;</span></span><br><span class="line"><span class="comment">     * 		token:&#x27;fdasfeffafdsfasfdasfdas&#x27;,</span></span><br><span class="line"><span class="comment">     * 		tokenExpireTime:&#x27;36000&#x27;</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//这里先拿到token，给每个请求添加一个token请求头</span></span><br><span class="line">    config.<span class="property">headers</span>[<span class="string">&#x27;token&#x27;</span>] = tokenInfo.<span class="property">token</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意：登录接口和刷新token接口是不需要token的</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      config.<span class="property">url</span>.<span class="title function_">indexOf</span>(<span class="string">&#x27;/refreshToken&#x27;</span>) &gt;= <span class="number">0</span> ||</span><br><span class="line">      config.<span class="property">url</span>.<span class="title function_">indexOf</span>(<span class="string">&#x27;/login&#x27;</span>) &gt;= <span class="number">0</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">return</span> config;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里是拦截的关键代码</span></span><br><span class="line">    <span class="keyword">if</span> (tokenInfo.<span class="property">token</span> &amp;&amp; tokenInfo.<span class="property">tokenExpireTime</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">      <span class="keyword">if</span> (now &gt;= tokenInfo.<span class="property">tokenExpireTime</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里已经过期了。</span></span><br><span class="line">        <span class="comment">//返回一个Promise，执行refreshToken后再return当前的config</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">refreshToken</span>()</span><br><span class="line">          .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> &#123; token, tokenExprieIn &#125; = res.<span class="property">data</span>;</span><br><span class="line">            <span class="comment">//重新把时间段转成绝对时间存起来</span></span><br><span class="line">            <span class="keyword">const</span> tokenExpireTime = now + tokenExprieIn * <span class="number">1000</span>;</span><br><span class="line">            instance.<span class="title function_">setToken</span>(&#123; token, tokenExpireTime &#125;); <span class="comment">// 存token到localStorage</span></span><br><span class="line">            config.<span class="property">headers</span>[<span class="string">&#x27;token&#x27;</span>] = token; <span class="comment">// 请求头重新赋值token</span></span><br><span class="line">            <span class="keyword">return</span> config;</span><br><span class="line">          &#125;)</span><br><span class="line">          .<span class="title function_">catch</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;token刷新error&#x27;</span>, res);</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="2-多个请求的情况"><a href="#2-多个请求的情况" class="headerlink" title="2.多个请求的情况"></a>2.多个请求的情况</h3><p>当刷新 token 的时间需要发送请求，则将这些请求缓存起来。使用一个 isRefresh 来判断 token 是否正在刷新。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">isRefresh = false</span><br><span class="line"></span><br><span class="line">instance.interceptors.request.use((config) =&gt; &#123;</span><br><span class="line">   //这里不单单是获取到token，还要一个token的过期时间，用来进行下面的判断</span><br><span class="line">   const tokenInfo = getToken()</span><br><span class="line">   /**</span><br><span class="line">    * 这里模拟一下tokenInfo的结构</span><br><span class="line">    * tokenInfo：&#123;</span><br><span class="line">    * 		token:&#x27;fdasfeffafdsfasfdasfdas&#x27;,</span><br><span class="line">    * 		tokenExpireTime:&#x27;36000&#x27;</span><br><span class="line">    * &#125;</span><br><span class="line">    */</span><br><span class="line">   //这里先拿到token，给每个请求添加一个token请求头</span><br><span class="line">     config.headers[&#x27;token&#x27;] = tokenInfo.token</span><br><span class="line"></span><br><span class="line">   // 注意：登录接口和刷新token接口是不需要token的</span><br><span class="line">     if (config.url.indexOf(&#x27;/refreshToken&#x27;) &gt;= 0 || config.url.indexOf(&#x27;/login&#x27;) &gt;= 0) &#123;</span><br><span class="line">       return config</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">   //这里是拦截的关键代码</span><br><span class="line">   if (tokenInfo.token &amp;&amp; tokenInfo.tokenExpireTime) &#123;</span><br><span class="line">         const now = Date.now()</span><br><span class="line">         if (now &gt;= tokenInfo.tokenExpireTime) &#123; // 这里已经过期了。</span><br><span class="line">             //返回一个Promise，执行refreshToken后再return当前的config</span><br><span class="line"></span><br><span class="line">             if (!isRefresh) &#123;</span><br><span class="line">                isRefresh = true</span><br><span class="line">                return refreshToken().then(res =&gt; &#123;</span><br><span class="line">                    const &#123; token, tokenExprieIn &#125; = res.data</span><br><span class="line">                    //重新把时间段转成绝对时间存起来</span><br><span class="line">                    const tokenExpireTime = now + tokenExprieIn * 1000</span><br><span class="line">                    instance.setToken(&#123; token, tokenExpireTime &#125;) // 存token到localStorage</span><br><span class="line">                    isRefresh = false //一旦刷新成功，再重置回去</span><br><span class="line">                    config.headers[&#x27;token&#x27;] = token // 请求头重新赋值token</span><br><span class="line">                    return config</span><br><span class="line">                &#125;).then((token) =&gt; &#123;</span><br><span class="line">                  console.log(&#x27;刷新token成功，执行队列&#x27;)</span><br><span class="line">                  //在token刷新成功后，才会继续执行队列</span><br><span class="line">                  requestsArr.forEach(item =&gt; item(token))</span><br><span class="line">                  // 执行完成后，清空队列</span><br><span class="line">                  requestsArr = []</span><br><span class="line">                &#125;).catch(res =&gt; &#123;</span><br><span class="line">                    console.error(&#x27;token刷新error&#x27;, res)</span><br><span class="line">                &#125;)</span><br><span class="line">             &#125;else&#123; //但是这样写还是会出问题，多次发起请求的顺序会乱，所以这边加个else</span><br><span class="line">                //这里第一个请求进不来</span><br><span class="line">                const retryOriginalRequest = new Promise((resolve) =&gt; &#123;</span><br><span class="line">                  requestsArr.push((token) =&gt; &#123;</span><br><span class="line">                    config.headers[&#x27;token&#x27;] = token</span><br><span class="line">                    resolve(config)</span><br><span class="line">                  &#125;)</span><br><span class="line">                &#125;)</span><br><span class="line">                return retryOriginalRequest</span><br><span class="line">              &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return config</span><br><span class="line">&#125;, (error) =&gt; &#123;</span><br><span class="line"> return Promise.reject(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="拓展-在响应拦截器中对-token-进行判断和刷新"><a href="#拓展-在响应拦截器中对-token-进行判断和刷新" class="headerlink" title="拓展-在响应拦截器中对 token 进行判断和刷新"></a>拓展-在响应拦截器中对 token 进行判断和刷新</h2><p>与后端约定，不需要传递 token 有效时间，在后端检验每次发起请求的 token 是否失效，如果失效返回一个状态码和新的 token，客户端保存新的 token，并携带新的 token 重新发起请求。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从localStorage中获取token</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getLocalToken</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> token = <span class="variable language_">window</span>.<span class="property">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;token&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> token;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给实例添加一个setToken方法，用于登录后将最新token动态添加到header，同时将token保存在localStorage中</span></span><br><span class="line">instance.<span class="property">setToken</span> = <span class="function">(<span class="params">token</span>) =&gt;</span> &#123;</span><br><span class="line">  instance.<span class="property">defaults</span>.<span class="property">headers</span>[<span class="string">&#x27;X-Token&#x27;</span>] = token;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;token&#x27;</span>, token);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">refreshToken</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// instance是当前request.js中已创建的axios实例</span></span><br><span class="line">  <span class="keyword">return</span> instance.<span class="title function_">post</span>(<span class="string">&#x27;/refreshtoken&#x27;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> res.<span class="property">data</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个axios实例</span></span><br><span class="line"><span class="keyword">const</span> instance = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;/api&#x27;</span>,</span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">300000</span>,</span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;X-Token&#x27;</span>: <span class="title function_">getLocalToken</span>(), <span class="comment">// headers塞token</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否正在刷新的标记</span></span><br><span class="line"><span class="keyword">let</span> isRefreshing = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 重试队列，每一项将是一个待执行的函数形式</span></span><br><span class="line"><span class="keyword">let</span> requests = [];</span><br><span class="line"></span><br><span class="line">instance.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; code &#125; = response.<span class="property">data</span>;</span><br><span class="line">    <span class="keyword">if</span> (code === <span class="number">1234</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> config = response.<span class="property">config</span>;</span><br><span class="line">      <span class="keyword">if</span> (!isRefreshing) &#123;</span><br><span class="line">        isRefreshing = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">refreshToken</span>()</span><br><span class="line">          .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> &#123; token &#125; = res.<span class="property">data</span>;</span><br><span class="line">            instance.<span class="title function_">setToken</span>(token);</span><br><span class="line">            config.<span class="property">headers</span>[<span class="string">&#x27;X-Token&#x27;</span>] = token;</span><br><span class="line">            config.<span class="property">baseURL</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            <span class="comment">// 已经刷新了token，将所有队列中的请求进行重试</span></span><br><span class="line">            requests.<span class="title function_">forEach</span>(<span class="function">(<span class="params">cb</span>) =&gt;</span> <span class="title function_">cb</span>(token));</span><br><span class="line">            requests = [];</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">instance</span>(config);</span><br><span class="line">          &#125;)</span><br><span class="line">          .<span class="title function_">catch</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;refreshtoken error =&gt;&#x27;</span>, res);</span><br><span class="line">            <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">          &#125;)</span><br><span class="line">          .<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            isRefreshing = <span class="literal">false</span>;</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 正在刷新token，将返回一个未执行resolve的promise</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 将resolve放进队列，用一个函数形式来保存，等token刷新后直接执行</span></span><br><span class="line">          requests.<span class="title function_">push</span>(<span class="function">(<span class="params">token</span>) =&gt;</span> &#123;</span><br><span class="line">            config.<span class="property">baseURL</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            config.<span class="property">headers</span>[<span class="string">&#x27;X-Token&#x27;</span>] = token;</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="title function_">instance</span>(config));</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> instance;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>token</category>
      </categories>
      <tags>
        <tag>token</tag>
        <tag>身份认证</tag>
      </tags>
  </entry>
  <entry>
    <title>样式穿透</title>
    <url>/2022/08/13/%E6%A0%B7%E5%BC%8F%E7%A9%BF%E9%80%8F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>vue的style中设置scoped属性后，组件实现样式<strong>私有化</strong>。<br> 但是该组件又使用的其他组件库时(vant,elementui,自定义等)，该组件的style中的样式，优先级低，不生效，这个时候需要使用样式穿透(作用得更深)。</p>
<h2 id="scoped原理"><a href="#scoped原理" class="headerlink" title="scoped原理"></a>scoped原理</h2><p>当一个style标签拥有scoped属性时，表明css样式只在该组件中生效，使用该修饰符会给dom生成唯一标识[data-v-xxxxxx]，可避免全局污染。</p>
<h3 id="加上scoped前"><a href="#加上scoped前" class="headerlink" title="加上scoped前"></a>加上scoped前</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;demo&quot;&gt;</span><br><span class="line">        样式穿透示例</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;style &gt;</span><br><span class="line">    .demo&#123;</span><br><span class="line">        color: rgba(255,0,0,0.5);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/19012724-cdcb7238a1a06ede.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp" alt="img"></p>
<h3 id="加上scoped后"><a href="#加上scoped后" class="headerlink" title="加上scoped后"></a>加上scoped后</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style scoped&gt;</span><br><span class="line">    .demo&#123;</span><br><span class="line">        color: rgba(255,0,0,0.5);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/19012724-7de21dd4cfee774e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/448/format/webp" alt="img"></p>
<p>通过图片可以看到scoped底层是通过在<code>DOM节点</code>中添加<code>data-v-xxx</code>，<code>CSS</code>中通过添加<code>[data-v-xxx]</code>属性过滤，提高优先级，来实现样式的私有化。</p>
<h2 id="为什么添加样式穿透"><a href="#为什么添加样式穿透" class="headerlink" title="为什么添加样式穿透"></a>为什么添加样式穿透</h2><p>看一个场景实例：子组件根元素颜色为<code>红色</code>，非根元素为<code>蓝色</code>。<br>父子两个组件<code>style</code>都使用<code>scoped</code>属性，在不修改子组件的前提下，在父组件上修改子组件的颜色为<code>绿色</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;c1&quot;&gt;</span><br><span class="line">        子组件根元素(red)</span><br><span class="line">        &lt;div class=&quot;c2&quot;&gt;</span><br><span class="line">            子组件非根元素(blue)</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">    .c1&#123;</span><br><span class="line">        border: 1px dashed #000;</span><br><span class="line">        margin-top: 10px;</span><br><span class="line">        padding: 5px;</span><br><span class="line">        color: red;</span><br><span class="line">    &#125;</span><br><span class="line">    .c1 .c2&#123;</span><br><span class="line">        border: 1px dotted #000;</span><br><span class="line">        color:blue;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">// 父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;demo&quot;&gt;</span><br><span class="line">        父组件</span><br><span class="line">        &lt;css-demo class=&quot;son&quot;&gt;&lt;/css-demo&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import cssDemo from &quot;./css-demo2.vue&quot;</span><br><span class="line">export default Vue.extend(&#123;</span><br><span class="line">    components:&#123; cssDemo &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">    .demo&#123;</span><br><span class="line">        width: 200px;</span><br><span class="line">        padding: 10px;</span><br><span class="line">        border: 1px solid rgba(0,0,0,1);</span><br><span class="line"></span><br><span class="line">        color: #000;</span><br><span class="line">    &#125;</span><br><span class="line">    .son&#123;</span><br><span class="line">        color: green;</span><br><span class="line">    &#125;</span><br><span class="line">    .son .c2&#123;</span><br><span class="line">        color: green !important;</span><br><span class="line">    &#125;</span><br><span class="line">    .c1 .c2&#123;</span><br><span class="line">        color: green !important;</span><br><span class="line">    &#125;</span><br><span class="line">    .son.c1 .c2&#123;</span><br><span class="line">        color: green !important;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/19012724-8b5bc364e38a5c52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/234/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/19012724-cd486f95e1742ed7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/591/format/webp" alt="img"></p>
<ul>
<li>可以看到只有子组件的根元素作用有生效，但是子组件的非根元素样式并没有生效，即使使用了<code>!important</code>。</li>
<li>scoped在渲染的时候，如果组件内部还有子组件，只会在子组件的根元素加上<code>data-v-xxx</code>属性。</li>
</ul>
<p>当加上样式穿透后</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">    &gt;&gt;&gt; .c1 .c2&#123;</span><br><span class="line">        color: green !important;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/19012724-ec6bc54308d121cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/590/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/19012724-27a076ca0c980b9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/233/format/webp" alt="img"></p>
<h2 id="样式穿透的方法"><a href="#样式穿透的方法" class="headerlink" title="样式穿透的方法"></a>样式穿透的方法</h2><p><code>vue</code>中针对不同的样式类型(<code>css</code>,<code>less</code>,<code>scss</code>)有不用的样式穿透方法。</p>
<ul>
<li><code>css</code> 使用 <code>&gt;&gt;&gt;</code></li>
<li><code>less</code> 使用 <code>/deep/</code></li>
<li><code>scss</code> 使用 <code>::v-deep</code></li>
</ul>
<h3 id="1-css"><a href="#1-css" class="headerlink" title="1. css"></a>1. css</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style scoped&gt;</span><br><span class="line">    &gt;&gt;&gt; .c1 .c2&#123;</span><br><span class="line">        color: green !important;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-less"><a href="#2-less" class="headerlink" title="2. less"></a>2. less</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style scoped lang=&quot;less&quot;&gt;</span><br><span class="line">    /deep/ .c1 .c2&#123;</span><br><span class="line">        color: green !important;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3-scss"><a href="#3-scss" class="headerlink" title="3. scss"></a>3. scss</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style scoped lang=”scss“&gt;</span><br><span class="line">    ::v-deep .c1 .c2&#123;</span><br><span class="line">        color: green !important;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂模式</title>
    <url>/2022/09/06/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在不暴露创建对象的具体逻辑，而是<strong>将创建对象的过程单独封装</strong>，那么它就可以被称为工厂。</p>
<p>工厂模式的目的，就是为了实现<strong>无脑传参</strong>。</p>
<p>工厂模式的设计思想即：</p>
<ul>
<li>将 new 操作单独封装，只对外提供相应接口</li>
<li>遇到new 时，就要考虑是否应该使用工厂模式</li>
</ul>
<p>优点</p>
<ol>
<li>调用者创建对象时只要知道其名称即可</li>
<li>扩展性高，如果要新增一个产品，直接扩展一个工厂类即可</li>
<li>隐藏产品的具体实现，只关心产品的接口</li>
</ol>
<p>缺点</p>
<ul>
<li>每次增加一个产品时，都需要增加一个具体类，这无形增加了系统内存的压力和系统的复杂度，也增加了具体类的依赖</li>
</ul>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>工厂模式根据抽象程度的不同可以分为：<code>简单工厂</code>，<code>工厂方法</code>和<code>抽象工厂</code>。</p>
<p>常见的栗子，我们的弹窗message，对外部提供API，都是调用API，然后新建一个弹窗或者message的实例，就是典型的工厂模式。</p>
<h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p><code>简单工厂模式</code>又叫<code>静态工厂模式</code>，由一个工厂对象决定创建某一种产品对象类的实例。主要用来创建同一类对象。</p>
<p>举例：</p>
<p>给不同工种分配职责说明</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">User</span>(<span class="params">name , age, career, work</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">career</span> = career </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">work</span> = work</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Factory</span>(<span class="params">name, age, career</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> work</span><br><span class="line">    <span class="keyword">switch</span>(career) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;coder&#x27;</span>:</span><br><span class="line">            work =  [<span class="string">&#x27;写代码&#x27;</span>,<span class="string">&#x27;写系分&#x27;</span>, <span class="string">&#x27;修Bug&#x27;</span>] </span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;product manager&#x27;</span>:</span><br><span class="line">            work = [<span class="string">&#x27;订会议室&#x27;</span>, <span class="string">&#x27;写PRD&#x27;</span>, <span class="string">&#x27;催更&#x27;</span>]</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;boss&#x27;</span>:</span><br><span class="line">            work = [<span class="string">&#x27;喝茶&#x27;</span>, <span class="string">&#x27;看报&#x27;</span>, <span class="string">&#x27;见客户&#x27;</span>]</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;xxx&#x27;</span>:</span><br><span class="line">            <span class="comment">// 其它工种的职责分配</span></span><br><span class="line">            ...</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(name, age, career, work)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Factory</span>(zs,<span class="number">24</span>,coder)</span><br></pre></td></tr></table></figure>

<p>通过上例，我们可以看到，每次创建新的对象实例时，只需要传入相应的参数，就可以得到指定的对象实例。</p>
<p>在实际的项目中，我们常常需要根据用户的权限来渲染不同的页面，高级权限的用户所拥有的页面有些是无法被低级权限的用户所查看。所以我们可以在不同权限等级用户的构造函数中，保存该用户能够看到的页面。在根据权限实例化用户。使用ES6重写简单工厂模式时，我们不再使用构造函数创建对象，而是使用class的新语法，并使用static关键字将简单工厂封装到<code>User</code>类的静态方法中.代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//User类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="comment">//构造器</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">opt</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = opt.<span class="property">name</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">viewPage</span> = opt.<span class="property">viewPage</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//静态方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getInstance</span>(<span class="params">role</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (role) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;superAdmin&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;超级管理员&#x27;</span>, <span class="attr">viewPage</span>: [<span class="string">&#x27;首页&#x27;</span>, <span class="string">&#x27;通讯录&#x27;</span>, <span class="string">&#x27;发现页&#x27;</span>, <span class="string">&#x27;应用数据&#x27;</span>, <span class="string">&#x27;权限管理&#x27;</span>] &#125;);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;admin&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;管理员&#x27;</span>, <span class="attr">viewPage</span>: [<span class="string">&#x27;首页&#x27;</span>, <span class="string">&#x27;通讯录&#x27;</span>, <span class="string">&#x27;发现页&#x27;</span>, <span class="string">&#x27;应用数据&#x27;</span>] &#125;);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;user&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;普通用户&#x27;</span>, <span class="attr">viewPage</span>: [<span class="string">&#x27;首页&#x27;</span>, <span class="string">&#x27;通讯录&#x27;</span>, <span class="string">&#x27;发现页&#x27;</span>] &#125;);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="attr">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;参数错误, 可选参数:superAdmin、admin、user&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="keyword">let</span> superAdmin = <span class="title class_">User</span>.<span class="title function_">getInstance</span>(<span class="string">&#x27;superAdmin&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> admin = <span class="title class_">User</span>.<span class="title function_">getInstance</span>(<span class="string">&#x27;admin&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> normalUser = <span class="title class_">User</span>.<span class="title function_">getInstance</span>(<span class="string">&#x27;user&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><code>User</code>就是一个简单工厂，在该函数中有3个实例中分别对应不同的权限的用户。当我们调用工厂函数时，只需要传递<code>superAdmin</code>, <code>admin</code>, <code>user</code>这三个可选参数中的一个获取对应的实例对象。</p>
<p>简单工厂的优点在于，你只需要一个正确的参数，就可以获取到你所需要的对象，而无需知道其创建的具体细节。但是在函数内包含了所有对象的创建逻辑（构造函数）和判断逻辑的代码，每增加新的构造函数还需要修改判断逻辑代码。当我们的对象不是上面的3个而是30个或更多时，这个函数会成为一个庞大的超级函数，便得难以维护。<strong>所以，简单工厂只能作用于创建的对象数量较少，对象的创建逻辑不复杂时使用</strong>。</p>
<p>例子2：</p>
<p>一个服装厂可以生产不同类型的衣服，我们通过一个工厂方法类来模拟产出</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DownJacket</span> &#123;</span><br><span class="line">  <span class="title function_">production</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;生产羽绒服&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Underwear</span>&#123;</span><br><span class="line">  <span class="title function_">production</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;生产内衣&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TShirt</span>&#123;</span><br><span class="line">  <span class="title function_">production</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;生产t恤&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">clothingFactory</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">downJacket</span> = <span class="title class_">DownJacket</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">underwear</span> = <span class="title class_">Underwear</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">t_shirt</span> = <span class="title class_">TShirt</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getFactory</span>(<span class="params">clothingType</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> _production = <span class="keyword">new</span> <span class="variable language_">this</span>[clothingType]</span><br><span class="line">    <span class="keyword">return</span> _production.<span class="title function_">production</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> clothing = <span class="keyword">new</span> <span class="title function_">clothingFactory</span>()</span><br><span class="line">clothing.<span class="title function_">getFactory</span>(<span class="string">&#x27;t_shirt&#x27;</span>)<span class="comment">// 生产t恤</span></span><br></pre></td></tr></table></figure>



<h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>工厂方法模式的本意是将<strong>实际创建对象的工作推迟到子类</strong>中，这样核心类就变成了抽象类。</p>
<p>在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name = <span class="string">&#x27;&#x27;</span>, viewPage = []</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">new</span>.<span class="property">target</span> === <span class="title class_">User</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;抽象类不能实例化!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">viewPage</span> = viewPage;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserFactory</span> <span class="keyword">extends</span> <span class="title class_ inherited__">User</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, viewPage</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name, viewPage)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">create</span>(<span class="params">role</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (role) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;superAdmin&#x27;</span>: </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserFactory</span>( <span class="string">&#x27;超级管理员&#x27;</span>, [<span class="string">&#x27;首页&#x27;</span>, <span class="string">&#x27;通讯录&#x27;</span>, <span class="string">&#x27;发现页&#x27;</span>, <span class="string">&#x27;应用数据&#x27;</span>, <span class="string">&#x27;权限管理&#x27;</span>] );</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;admin&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserFactory</span>( <span class="string">&#x27;普通用户&#x27;</span>, [<span class="string">&#x27;首页&#x27;</span>, <span class="string">&#x27;通讯录&#x27;</span>, <span class="string">&#x27;发现页&#x27;</span>] );</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;user&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserFactory</span>( <span class="string">&#x27;普通用户&#x27;</span>, [<span class="string">&#x27;首页&#x27;</span>, <span class="string">&#x27;通讯录&#x27;</span>, <span class="string">&#x27;发现页&#x27;</span>] );</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="attr">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;参数错误, 可选参数:superAdmin、admin、user&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> userFactory = <span class="keyword">new</span> <span class="title class_">UserFactory</span>();</span><br><span class="line"><span class="keyword">let</span> superAdmin = userFactory.<span class="title function_">create</span>(<span class="string">&#x27;superAdmin&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> admin = userFactory.<span class="title function_">create</span>(<span class="string">&#x27;admin&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> user = userFactory.<span class="title function_">create</span>(<span class="string">&#x27;user&#x27;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>抽象工厂模式是工厂方法模式的升级版本，他用来创建一组相关或者相互依赖的对象。他与工厂方法模式的区别就在于，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则是针对的多个产品等级结构。在编程中，通常一个产品结构，表现为一个接口或者抽象类，也就是说，工厂方法模式提供的所有产品都是衍生自同一个接口或抽象类，而抽象工厂模式所提供的产品则是衍生自不同的接口或抽象类。</p>
<p>大家知道一部智能手机的基本组成是操作系统（Operating System，我们下面缩写作 OS）和硬件（HardWare）组成。所以说如果我要开一个山寨手机工厂，那我这个工厂里必须是既准备好了操作系统，也准备好了硬件，才能实现手机的<strong>量产</strong>。考虑到操作系统和硬件这两样东西背后也存在不同的厂商，而我现在<strong>并不知道我下一个生产线到底具体想生产一台什么样的手机</strong>，我只知道手机必须有这两部分组成，所以我先来一个抽象类来<strong>约定住这台手机的基本组成</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MobilePhoneFactory</span> &#123;</span><br><span class="line">    <span class="comment">// 提供操作系统的接口</span></span><br><span class="line">    <span class="title function_">createOS</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;抽象工厂方法不允许直接调用，你需要将我重写！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 提供硬件的接口</span></span><br><span class="line">    <span class="title function_">createHardWare</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;抽象工厂方法不允许直接调用，你需要将我重写！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>楼上这个类，除了约定手机流水线的通用能力之外，啥也不干。如果你尝试让它干点啥，比如 new 一个 <code>MobilePhoneFactory</code> 实例，并尝试调用它的实例方法。它还会给你报错，提醒你“我不是让你拿去new一个实例的，我就是个定规矩的”。在抽象工厂模式里，楼上这个类就是我们食物链顶端最大的 <code>Boss——AbstractFactory</code>（抽象工厂）。</p>
<p>抽象工厂不干活，具体工厂（ConcreteFactory）来干活！当我们明确了生产方案，明确某一条手机生产流水线具体要生产什么样的手机了之后，就可以化抽象为具体，比如我现在想要一个专门生产 Android 系统 + 高通硬件的手机的生产线，我给这类手机型号起名叫 FakeStar，那我就可以为 FakeStar 定制一个具体工厂：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体工厂继承自抽象工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FakeStarFactory</span> <span class="keyword">extends</span> <span class="title class_ inherited__">MobilePhoneFactory</span> &#123;</span><br><span class="line">    <span class="title function_">createOS</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 提供安卓系统实例</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AndroidOS</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">createHardWare</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 提供高通硬件实例</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">QualcommHardWare</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们在提供安卓系统的时候，调用了两个构造函数：AndroidOS 和 QualcommHardWare，它们分别用于生成具体的操作系统和硬件实例。像这种被我们拿来用于 new 出具体对象的类，叫做具体产品类（ConcreteProduct）。具体产品类往往不会孤立存在，不同的具体产品类往往有着共同的功能，比如安卓系统类和苹果系统类，它们都是操作系统，都有着可以<strong>操控手机硬件系统</strong>这样一个最基本的功能。因此我们可以用一个<strong>抽象产品（AbstractProduct）类</strong>来声明这一类产品应该具有的基本功能（众：什么抽象产品？？？要这些玩意儿干啥？老夫写代码就是一把梭，为啥不让我老老实实一个一个写具体类？？？大家稍安勿躁，先把例子看完，下文会有解释）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义操作系统这类产品的抽象产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OS</span> &#123;</span><br><span class="line">    <span class="title function_">controlHardWare</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;抽象产品方法不允许直接调用，你需要将我重写！&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义具体操作系统的具体产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AndroidOS</span> <span class="keyword">extends</span> <span class="title class_ inherited__">OS</span> &#123;</span><br><span class="line">    <span class="title function_">controlHardWare</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我会用安卓的方式去操作硬件&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AppleOS</span> <span class="keyword">extends</span> <span class="title class_ inherited__">OS</span> &#123;</span><br><span class="line">    <span class="title function_">controlHardWare</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我会用🍎的方式去操作硬件&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>硬件类产品同理：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义手机硬件这类产品的抽象产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HardWare</span> &#123;</span><br><span class="line">    <span class="comment">// 手机硬件的共性方法，这里提取了“根据命令运转”这个共性</span></span><br><span class="line">    <span class="title function_">operateByOrder</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;抽象产品方法不允许直接调用，你需要将我重写！&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义具体硬件的具体产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QualcommHardWare</span> <span class="keyword">extends</span> <span class="title class_ inherited__">HardWare</span> &#123;</span><br><span class="line">    <span class="title function_">operateByOrder</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我会用高通的方式去运转&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MiWare</span> <span class="keyword">extends</span> <span class="title class_ inherited__">HardWare</span> &#123;</span><br><span class="line">    <span class="title function_">operateByOrder</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我会用小米的方式去运转&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>好了，如此一来，当我们需要生产一台FakeStar手机时，我们只需要这样做：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是我的手机</span></span><br><span class="line"><span class="keyword">const</span> myPhone = <span class="keyword">new</span> <span class="title class_">FakeStarFactory</span>()</span><br><span class="line"><span class="comment">// 让它拥有操作系统</span></span><br><span class="line"><span class="keyword">const</span> myOS = myPhone.<span class="title function_">createOS</span>()</span><br><span class="line"><span class="comment">// 让它拥有硬件</span></span><br><span class="line"><span class="keyword">const</span> myHardWare = myPhone.<span class="title function_">createHardWare</span>()</span><br><span class="line"><span class="comment">// 启动操作系统(输出‘我会用安卓的方式去操作硬件’)</span></span><br><span class="line">myOS.<span class="title function_">controlHardWare</span>()</span><br><span class="line"><span class="comment">// 唤醒硬件(输出‘我会用高通的方式去运转’)</span></span><br><span class="line">myHardWare.<span class="title function_">operateByOrder</span>()</span><br></pre></td></tr></table></figure>

<p>关键的时刻来了——假如有一天，FakeStar过气了，我们需要产出一款新机投入市场，这时候怎么办？我们是不是<strong>不需要对抽象工厂MobilePhoneFactory做任何修改</strong>，只需要拓展它的种类：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">newStarFactory</span> <span class="keyword">extends</span> <span class="title class_ inherited__">MobilePhoneFactory</span> &#123;</span><br><span class="line">    <span class="title function_">createOS</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 操作系统实现代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">createHardWare</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 硬件实现代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这么个操作，<strong>对原有的系统不会造成任何潜在影响</strong> 所谓的“对拓展开放，对修改封闭”就这么圆满实现了。前面我们之所以要实现<strong>抽象产品类</strong>，也是同样的道理。</p>
<p>总结：</p>
<p>简单工厂模式又叫静态工厂方法，用来创建某一种产品对象的实例，用来创建单一对象；工厂方法模式是将创建实例推迟到子类中进行；抽象工厂模式是对类的工厂抽象用来创建产品类簇，不负责创建某一类产品的实例。</p>
<p>参考文章：</p>
<p><a href="https://juejin.cn/book/6844733790204461070/section">JavaScript 设计模式核⼼原理与应⽤实践</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>工厂模式</tag>
      </tags>
  </entry>
</search>
