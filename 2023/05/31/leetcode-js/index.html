<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zhdzb.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="2618.检查是否是类的对象实例请你编写一个函数，检查给定的对象是否是给定类或超类的实例。 可以传递给函数的数据类型没有限制。 示例 1： 123输入：func &#x3D; () &#x3D;&gt; checkIfInstance(new Date(), Date)输出：true解释：根据定义，Date 构造函数返回的对象是 Date 的一个实例。  题解12345678910111213141516functi">
<meta property="og:type" content="article">
<meta property="og:title" content="leetcode-js">
<meta property="og:url" content="https://zhdzb.github.io/2023/05/31/leetcode-js/index.html">
<meta property="og:site_name" content="zhdzb">
<meta property="og:description" content="2618.检查是否是类的对象实例请你编写一个函数，检查给定的对象是否是给定类或超类的实例。 可以传递给函数的数据类型没有限制。 示例 1： 123输入：func &#x3D; () &#x3D;&gt; checkIfInstance(new Date(), Date)输出：true解释：根据定义，Date 构造函数返回的对象是 Date 的一个实例。  题解12345678910111213141516functi">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2023/04/10/screen-shot-2023-04-10-at-100006-pm.png">
<meta property="article:published_time" content="2023-05-30T16:00:00.000Z">
<meta property="article:modified_time" content="2023-06-09T08:31:31.794Z">
<meta property="article:author" content="z">
<meta property="article:tag" content="手写题">
<meta property="article:tag" content="js">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://assets.leetcode.com/uploads/2023/04/10/screen-shot-2023-04-10-at-100006-pm.png">

<link rel="canonical" href="https://zhdzb.github.io/2023/05/31/leetcode-js/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>leetcode-js | zhdzb</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="zhdzb" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">zhdzb</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/zhdzb/zhdzb.github.io" class="github-corner" title="Zzz" aria-label="Zzz" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhdzb.github.io/2023/05/31/leetcode-js/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="z">
      <meta itemprop="description" content="记录前端学习内容">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhdzb">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          leetcode-js
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-31 00:00:00" itemprop="dateCreated datePublished" datetime="2023-05-31T00:00:00+08:00">2023-05-31</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%89%8B%E5%86%99/" itemprop="url" rel="index"><span itemprop="name">手写</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>44 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="2618-检查是否是类的对象实例"><a href="#2618-检查是否是类的对象实例" class="headerlink" title="2618.检查是否是类的对象实例"></a>2618.检查是否是类的对象实例</h2><p>请你编写一个函数，检查给定的对象是否是给定类或超类的实例。</p>
<p>可以传递给函数的数据类型没有限制。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：func = () =&gt; checkIfInstance(new Date(), Date)</span><br><span class="line">输出：true</span><br><span class="line">解释：根据定义，Date 构造函数返回的对象是 Date 的一个实例。</span><br></pre></td></tr></table></figure>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">checkIfInstanceOf</span>(<span class="params">obj: <span class="built_in">any</span>, classFunction: <span class="built_in">any</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(obj == <span class="literal">null</span> || obj == <span class="literal">undefined</span> || <span class="keyword">typeof</span> classFunction !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj) == classFunction.<span class="property"><span class="keyword">prototype</span></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        obj = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * checkIfInstanceOf(new Date(), Date); // true</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="2619-数组原型对象的最后一个元素"><a href="#2619-数组原型对象的最后一个元素" class="headerlink" title="2619.数组原型对象的最后一个元素"></a>2619.数组原型对象的最后一个元素</h2><p>请你编写一段代码实现一个数组方法，使任何数组都可以调用 <code>array.last()</code> 方法，这个方法将返回数组最后一个元素。如果数组中没有元素，则返回 <code>-1</code> 。</p>
<p><strong>示例 1 ：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：3</span><br><span class="line">解释：调用 nums.last() 后返回最后一个元素： 3。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2 ：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = []</span><br><span class="line">输出：-1</span><br><span class="line">解释：因为此数组没有元素，所以应该返回 -1。</span><br></pre></td></tr></table></figure>

<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable language_">global</span> &#123;</span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Array</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="title function_">last</span>(): T | -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">last</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">length</span> &lt;= <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>[<span class="variable language_">this</span>.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2620-计数器"><a href="#2620-计数器" class="headerlink" title="2620.计数器"></a>2620.计数器</h2><p>请你编写并返回一个 <strong>计数器</strong> 函数，它接收一个整型参数 n 。这个 <strong>计数器</strong> 函数最初返回 n，每次调用它时返回前一个值加 1 的值 ( <code>n</code> , <code>n + 1</code> , <code>n + 2</code> ，等等)。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">n = 10 </span><br><span class="line">[&quot;call&quot;,&quot;call&quot;,&quot;call&quot;]</span><br><span class="line">输出：[10,11,12]</span><br><span class="line">解释：</span><br><span class="line">counter() = 10 // 第一次调用 counter()，返回 n。</span><br><span class="line">counter() = 11 // 返回上次调用的值加 1。</span><br><span class="line">counter() = 12 // 返回上次调用的值加 1。</span><br></pre></td></tr></table></figure>

<h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createCounter</span>(<span class="params">n: <span class="built_in">number</span></span>): <span class="function">() =&gt;</span> <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> count = n;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * const counter = createCounter(10)</span></span><br><span class="line"><span class="comment"> * counter() // 10</span></span><br><span class="line"><span class="comment"> * counter() // 11</span></span><br><span class="line"><span class="comment"> * counter() // 12</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="2621-睡眠函数"><a href="#2621-睡眠函数" class="headerlink" title="2621.睡眠函数"></a>2621.睡眠函数</h2><p>请你编写一个异步函数，它接收一个正整数参数 <code>millis</code> ，并休眠这么多毫秒。要求此函数可以解析任何值。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：millis = 100</span><br><span class="line">输出：100</span><br><span class="line">解释：</span><br><span class="line">在 100ms 后此异步函数执行完时返回一个 Promise 对象</span><br><span class="line">let t = Date.now();</span><br><span class="line">sleep(100).then(() =&gt; &#123;</span><br><span class="line">  console.log(Date.now() - t); // 100</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">sleep</span>(<span class="params">millis: <span class="built_in">number</span></span>): <span class="title class_">Promise</span>&lt;<span class="built_in">void</span>&gt; &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(), millis);</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * let t = Date.now()</span></span><br><span class="line"><span class="comment"> * sleep(100).then(() =&gt; console.log(Date.now() - t)) // 100</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="2622-有时间限制的缓存"><a href="#2622-有时间限制的缓存" class="headerlink" title="2622.有时间限制的缓存"></a>2622.有时间限制的缓存</h2><p>编写一个类，它允许获取和设置键-值对，并且每个键都有一个 <strong>过期时间</strong> 。</p>
<p>该类有三个公共方法：</p>
<p><code>set(key, value, duration)</code> ：接收参数为整型键 <code>key</code> 、整型值 <code>value</code> 和以毫秒为单位的持续时间 <code>duration</code> 。一旦 <code>duration</code> 到期后，这个键就无法访问。如果相同的未过期键已经存在，该方法将返回 <code>true</code> ，否则返回 <code>false</code> 。如果该键已经存在，则它的值和持续时间都应该被覆盖。</p>
<p><code>get(key)</code> ：如果存在一个未过期的键，它应该返回这个键相关的值。否则返回 <code>-1</code> 。</p>
<p><code>count()</code> ：返回未过期键的总数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入： </span><br><span class="line">[&quot;TimeLimitedCache&quot;, &quot;set&quot;, &quot;get&quot;, &quot;count&quot;, &quot;get&quot;]</span><br><span class="line">[[], [1, 42, 100], [1], [], [1]]</span><br><span class="line">[0, 0, 50, 50, 150]</span><br><span class="line">输出： [null, false, 42, 1, -1]</span><br><span class="line">解释：</span><br><span class="line">在 t=0 时，缓存被构造。</span><br><span class="line">在 t=0 时，添加一个键值对 (1: 42) ，过期时间为 100ms 。因为该值不存在，因此返回false。</span><br><span class="line">在 t=50 时，请求 key=1 并返回值 42。</span><br><span class="line">在 t=50 时，调用 count() ，缓存中有一个未过期的键。</span><br><span class="line">在 t=100 时，key=1 到期。</span><br><span class="line">在 t=150 时，调用 get(1) ，返回 -1，因为缓存是空的。</span><br></pre></td></tr></table></figure>

<h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><h4 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h4><p>使用定时器，到时间之后直接删除map中的key。</p>
<p><strong>注意：ts中直接获取setTimeout获得的不是number，<code>window.setTimerout</code>获得的才是number</strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TimeLimitedCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>&lt;<span class="built_in">number</span>, <span class="built_in">number</span>&gt;()</span><br><span class="line">    <span class="keyword">private</span> timers = <span class="keyword">new</span> <span class="title class_">Map</span>&lt;<span class="built_in">number</span>, <span class="built_in">any</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="title function_">set</span>(<span class="attr">key</span>: <span class="built_in">number</span>, <span class="attr">value</span>: <span class="built_in">number</span>, <span class="attr">duration</span>: <span class="built_in">number</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> res = <span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">has</span>(key);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">set</span>(key, value);</span><br><span class="line">        <span class="keyword">let</span> timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">delete</span>(key), duration);</span><br><span class="line">        <span class="built_in">clearTimeout</span>(<span class="variable language_">this</span>.<span class="property">timers</span>.<span class="title function_">get</span>(key));</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">timers</span>.<span class="title function_">set</span>(key, timer);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">get</span>(<span class="attr">key</span>: <span class="built_in">number</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">has</span>(key) ? <span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">get</span>(key) : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="title function_">count</span>(): <span class="built_in">number</span> &#123;</span><br><span class="line">        <span class="comment">// return [...this.map.keys()].length;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">map</span>.<span class="property">size</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h4><p>直接通过Data.now()来实现。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TimeLimitedCache</span> &#123;</span><br><span class="line">    cache = <span class="keyword">new</span> <span class="title class_">Map</span>&lt;<span class="built_in">number</span>, [<span class="built_in">number</span>, <span class="built_in">number</span>]&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="title function_">set</span>(<span class="attr">key</span>: <span class="built_in">number</span>, <span class="attr">value</span>: <span class="built_in">number</span>, <span class="attr">duration</span>: <span class="built_in">number</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">        <span class="keyword">const</span> item = <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">get</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (item) &#123;</span><br><span class="line">            item[<span class="number">0</span>] = now + duration;</span><br><span class="line">            item[<span class="number">1</span>] = value;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">set</span>(key, [now + duration, value]);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">get</span>(<span class="attr">key</span>: <span class="built_in">number</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">        <span class="keyword">const</span> item = <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">get</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (!item || now &gt; item[<span class="number">0</span>]) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> item[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">count</span>(): <span class="built_in">number</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">        <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> [key, item] <span class="keyword">of</span> <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (now &gt; item[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">delete</span>(key);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h4><p>使用闭包+defineProperty来控制数据的访问。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TimeLimitedCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> caches = &#123;&#125;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当连续set同一个key时，每一个定时器修改的都是自己作用域中的valid</span></span><br><span class="line">    <span class="title function_">set</span>(<span class="attr">key</span>: <span class="built_in">number</span>, <span class="attr">value</span>: <span class="built_in">number</span>, <span class="attr">duration</span>: <span class="built_in">number</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> flag = <span class="variable language_">this</span>.<span class="title function_">get</span>(key) != -<span class="number">1</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">let</span> valid = <span class="literal">true</span>;   <span class="comment">// 闭包保存当前key所对应的value和valid</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> valid = <span class="literal">false</span>, duration)   <span class="comment">// 到时间后将valid改为false</span></span><br><span class="line">        <span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(<span class="variable language_">this</span>.<span class="property">caches</span>, key, &#123;</span><br><span class="line">            <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(valid) &#123;</span><br><span class="line">                    <span class="keyword">return</span> value;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">enumerable</span>: <span class="literal">true</span>,   <span class="comment">// 让getter可以被覆盖和遍历</span></span><br><span class="line">            <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">get</span>(<span class="attr">key</span>: <span class="built_in">number</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">caches</span>[key] || -<span class="number">1</span>;  <span class="comment">// key不存在或者过期返回-1（注意有些key是没有getter的）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="title function_">count</span>(): <span class="built_in">number</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> k <span class="keyword">in</span> <span class="variable language_">this</span>.<span class="property">caches</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">get</span>(k <span class="keyword">as</span> <span class="built_in">any</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">                n++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2623-记忆函数"><a href="#2623-记忆函数" class="headerlink" title="2623.记忆函数"></a>2623.记忆函数</h2><p>请你编写一个函数，它接收另一个函数作为输入，并返回该函数的 <strong>记忆化</strong> 后的结果。</p>
<p><strong>记忆函数</strong> 是一个对于相同的输入永远不会被调用两次的函数。相反，它将返回一个缓存值。</p>
<p>你可以假设有 <strong>3</strong> 个可能的输入函数：<code>sum</code> 、<code>fib</code> 和 <code>factorial</code> 。</p>
<h3 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Fn</span> = <span class="function">(<span class="params">...params: <span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">any</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">memoize</span>(<span class="params">fn: Fn</span>): <span class="title class_">Fn</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>&lt;<span class="built_in">string</span>, <span class="built_in">any</span>&gt;();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> key = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(args);</span><br><span class="line">        <span class="keyword">if</span>(map.<span class="title function_">has</span>(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> map.<span class="title function_">get</span>(key)</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> result = <span class="title function_">fn</span>(...args);</span><br><span class="line">            map.<span class="title function_">set</span>(key, result);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * let callCount = 0;</span></span><br><span class="line"><span class="comment"> * const memoizedFn = memoize(function (a, b) &#123;</span></span><br><span class="line"><span class="comment"> *	 callCount += 1;</span></span><br><span class="line"><span class="comment"> *   return a + b;</span></span><br><span class="line"><span class="comment"> * &#125;)</span></span><br><span class="line"><span class="comment"> * memoizedFn(2, 3) // 5</span></span><br><span class="line"><span class="comment"> * memoizedFn(2, 3) // 5</span></span><br><span class="line"><span class="comment"> * console.log(callCount) // 1 </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>一开始直接将<code>[...args]</code>作为map的key，后面出现了错误。思考了一下，应该是map只会将引用数据类型的地址作为key，而不是值，所以最好将key设置为基本数据类型。</p>
<blockquote>
<p>在 TypeScript 中，数组同样可以作为 Map 的键，但有一些限制和注意事项：</p>
<ol>
<li>TypeScript 的类型系统会强制执行严格的键类型检查。这意味着在声明 Map 的类型时，需要指定数组作为键的类型。</li>
<li>与 JavaScript 类似，数组作为 Map 键时会被转换为字符串作为实际的键值存储。因此，相同的数组元素但顺序不同的数组会被视为不同的键。</li>
</ol>
</blockquote>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">map</span>: <span class="title class_">Map</span>&lt;<span class="built_in">number</span>[], <span class="built_in">string</span>&gt; = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">key1</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="attr">key2</span>: <span class="built_in">number</span>[] = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">map.<span class="title function_">set</span>(key1, <span class="string">&#x27;Value 1&#x27;</span>);</span><br><span class="line">map.<span class="title function_">set</span>(key2, <span class="string">&#x27;Value 2&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">get</span>(key1)); <span class="comment">// 输出: Value 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">get</span>(key2)); <span class="comment">// 输出: Value 2</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">get</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])); <span class="comment">// 输出: undefined，因为新数组和 key1 不是同一个引用</span></span><br></pre></td></tr></table></figure>

<h2 id="2624-蜗牛排序"><a href="#2624-蜗牛排序" class="headerlink" title="2624.蜗牛排序"></a>2624.蜗牛排序</h2><p>请你编写一段代码为所有数组实现 <code>snail(rowsCount，colsCount)</code> 方法，该方法将 1D 数组转换为以蜗牛排序的模式的 2D 数组。无效的输入值应该输出一个空数组。当 <code>rowsCount * colsCount !==``nums.length</code> 时。这个输入被认为是无效的。</p>
<p>蜗牛排序从左上角的单元格开始，从当前数组的第一个值开始。然后，它从上到下遍历第一列，接着移动到右边的下一列，并从下到上遍历它。将这种模式持续下去，每列交替变换遍历方向，直到覆盖整个数组。例如，当给定输入数组 <code>[19, 10, 3, 7, 9, 8, 5, 2, 1, 17, 16, 14, 12, 18, 6, 13, 11, 20, 4, 15]</code> ，当 <code>rowsCount = 5</code> 且 <code>colsCount = 4</code> 时，需要输出矩阵如下图所示。注意，矩阵沿箭头方向对应于原数组中数字的顺序</p>
<p><img src="https://assets.leetcode.com/uploads/2023/04/10/screen-shot-2023-04-10-at-100006-pm.png" alt="Traversal Diagram"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">nums = [19, 10, 3, 7, 9, 8, 5, 2, 1, 17, 16, 14, 12, 18, 6, 13, 11, 20, 4, 15]</span><br><span class="line">rowsCount = 5</span><br><span class="line">colsCount = 4</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line"> [19,17,16,15],</span><br><span class="line"> [10,1,14,4],</span><br><span class="line"> [3,2,12,20],</span><br><span class="line"> [7,5,18,11],</span><br><span class="line"> [9,8,6,13]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h3><h4 id="解法一-1"><a href="#解法一-1" class="headerlink" title="解法一"></a>解法一</h4><p>思路主要就是写一个数组作为存放结果的容器res，然后按照蜗牛排序的顺序遍历这个res来往里面填内容。我用了两个遍历来模拟正方向和反方向</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable language_">global</span> &#123;</span><br><span class="line">  <span class="keyword">interface</span> <span class="title class_">Array</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="title function_">snail</span>(<span class="attr">rowsCount</span>: <span class="built_in">number</span>, <span class="attr">colsCount</span>: <span class="built_in">number</span>): <span class="built_in">number</span>[][];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">snail</span> = <span class="keyword">function</span>(<span class="params">rowsCount: <span class="built_in">number</span>, colsCount: <span class="built_in">number</span></span>): <span class="built_in">number</span>[][] &#123;</span><br><span class="line">    <span class="keyword">if</span>(rowsCount * colsCount !== <span class="variable language_">this</span>.<span class="property">length</span>) <span class="keyword">return</span> []; </span><br><span class="line">    <span class="keyword">let</span> res = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: rowsCount &#125;, <span class="function">() =&gt;</span> <span class="title class_">Array</span>(colsCount).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>, isResverse = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> col = <span class="number">0</span>; col &lt; colsCount; col++ ) &#123;</span><br><span class="line">        <span class="keyword">if</span>(isResverse) &#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">let</span> row = rowsCount - <span class="number">1</span>; row &gt;= <span class="number">0</span>; row--) &#123;</span><br><span class="line">            res[row][col] = <span class="variable language_">this</span>[count++];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">let</span> row = <span class="number">0</span>; row &lt; rowsCount; row++) &#123;</span><br><span class="line">            res[row][col] = <span class="variable language_">this</span>[count++];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        isResverse = !isResverse</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * const arr = [1,2,3,4];</span></span><br><span class="line"><span class="comment"> * arr.snail(1,4); // [[1,2,3,4]]</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>gpt简化的版本</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">snail</span> = <span class="keyword">function</span>(<span class="params">rowsCount: <span class="built_in">number</span>, colsCount: <span class="built_in">number</span></span>): <span class="built_in">number</span>[][] &#123;</span><br><span class="line">    <span class="keyword">if</span> (rowsCount * colsCount !== <span class="variable language_">this</span>.<span class="property">length</span>) <span class="keyword">return</span> [];</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">const</span> <span class="attr">res</span>: <span class="built_in">number</span>[][] = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: rowsCount &#125;, <span class="function">() =&gt;</span> <span class="title class_">Array</span>(colsCount).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> isReverse = <span class="literal">false</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> col = <span class="number">0</span>; col &lt; colsCount; col++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> row = isReverse ? rowsCount - <span class="number">1</span> : <span class="number">0</span>; isReverse ? row &gt;= <span class="number">0</span> : row &lt; rowsCount; isReverse ? row-- : row++) &#123;</span><br><span class="line">            res[row][col] = <span class="variable language_">this</span>[count++];</span><br><span class="line">        &#125;</span><br><span class="line">        isReverse = !isReverse;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解法二-1"><a href="#解法二-1" class="headerlink" title="解法二"></a>解法二</h4><p>使用数学方法，通过数学计算来选择要填入的数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">rowsCount</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">colsCount</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">Array&lt;Array&lt;number&gt;&gt;</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">snail</span> = <span class="keyword">function</span>(<span class="params">rowsCount, colsCount</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">length</span> !== rowsCount * colsCount) &#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; rowsCount; i++) &#123;</span><br><span class="line">        res.<span class="title function_">push</span>([]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> seq = <span class="literal">true</span>; <span class="comment">// 正向还是逆向</span></span><br><span class="line">    <span class="keyword">let</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        res[start].<span class="title function_">push</span>(<span class="variable language_">this</span>[i]);</span><br><span class="line">        <span class="keyword">if</span> (seq) &#123;</span><br><span class="line">            <span class="keyword">if</span> (start === rowsCount - <span class="number">1</span>) &#123;</span><br><span class="line">                seq = <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (start === <span class="number">0</span>) &#123;</span><br><span class="line">                seq = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                start--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * const arr = [1,2,3,4];</span></span><br><span class="line"><span class="comment"> * arr.snail(1,4); // [[1,2,3,4]]</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="给定row-col生成一个空数组的方法-Array-from-Array-fill-Array-map"><a href="#给定row-col生成一个空数组的方法-Array-from-Array-fill-Array-map" class="headerlink" title="给定row col生成一个空数组的方法(Array.from()  Array.fill()  Array.map())"></a>给定row col生成一个空数组的方法(Array.from()  Array.fill()  Array.map())</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from</span></span><br><span class="line"><span class="keyword">const</span> rowsCount = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> colsCount = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> matrix = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: rowsCount &#125;, <span class="function">() =&gt;</span> <span class="title class_">Array</span>(colsCount));</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matrix);</span><br><span class="line"></span><br><span class="line"><span class="comment">// fill</span></span><br><span class="line"><span class="keyword">const</span> rowsCount = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> colsCount = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> matrix = <span class="title class_">Array</span>(rowsCount).<span class="title function_">fill</span>([]);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matrix);</span><br><span class="line"></span><br><span class="line"><span class="comment">// map</span></span><br><span class="line"><span class="keyword">const</span> rowsCount = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> colsCount = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> matrix = <span class="title class_">Array</span>(rowsCount).<span class="title function_">map</span>(<span class="function">() =&gt;</span> []);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matrix);</span><br></pre></td></tr></table></figure>

<h2 id="2625-扁平化嵌套数组"><a href="#2625-扁平化嵌套数组" class="headerlink" title="2625.扁平化嵌套数组"></a>2625.扁平化嵌套数组</h2><p>请你编写一个函数，它接收一个 <strong>多维数组</strong> <code>arr</code> 和它的深度 <code>n</code> ，并返回该数组的 <strong>扁平化</strong> 后的结果。</p>
<p><strong>多维数组</strong> 是一种包含整数或其他 <strong>多维数组</strong> 的递归数据结构。</p>
<p>数组 <strong>扁平化</strong> 是对数组的一种操作，定义是将原数组部分或全部子数组删除，并替换为该子数组中的实际元素。只有当嵌套的数组深度大于 <code>n</code> 时，才应该执行扁平化操作。第一层数组中元素的深度被认为是 0。</p>
<p>请在没有使用内置方法 <code>Array.flat</code> 的前提下解决这个问题。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">arr = [1, 2, 3, [4, 5, 6], [7, 8, [9, 10, 11], 12], [13, 14, 15]]</span><br><span class="line">n = 0</span><br><span class="line">输出</span><br><span class="line">[1, 2, 3, [4, 5, 6], [7, 8, [9, 10, 11], 12], [13, 14, 15]]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">传递深度 n=0 的多维数组将始终得到原始数组。这是因为 子数组(0) 的最小可能的深度不小于 n=0 。因此，任何子数组都不应该被平面化。</span><br></pre></td></tr></table></figure>

<h3 id="题解-7"><a href="#题解-7" class="headerlink" title="题解"></a>题解</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MultiDimensionalArray</span> = (<span class="built_in">number</span> | <span class="title class_">MultiDimensionalArray</span>)[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> flat = <span class="keyword">function</span> (<span class="params">arr:  MultiDimensionalArray, n: <span class="built_in">number</span></span>):  <span class="title class_">MultiDimensionalArray</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr.<span class="property">reduce</span>&lt;<span class="title class_">MultiDimensionalArray</span>&gt;(<span class="function">(<span class="params">prev, item</span>) =&gt;</span> &#123;</span><br><span class="line">        item <span class="keyword">instanceof</span> <span class="title class_">Array</span> ? prev.<span class="title function_">push</span>(...<span class="title function_">flat</span>(item, n - <span class="number">1</span>)) : prev.<span class="title function_">push</span>(item)</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;, [])</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><p>如果是</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, item</span>) =&gt;</span> &#123;</span><br><span class="line">        item <span class="keyword">instanceof</span> <span class="title class_">Array</span> ? prev.<span class="title function_">push</span>(...<span class="title function_">flat</span>(item, n - <span class="number">1</span>)) : prev.<span class="title function_">push</span>(item)</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;, [])</span><br></pre></td></tr></table></figure>

<p>会触发类型错误，需要加上类型。</p>
<h2 id="2626-数组归约运算"><a href="#2626-数组归约运算" class="headerlink" title="2626.数组归约运算"></a>2626.数组归约运算</h2><p>请你编写一个函数，它的参数为一个整数数组 <code>nums</code> 、一个计算函数 <code>fn</code> 和初始值 init 。返回一个数组 <strong>归约后</strong> 的值。</p>
<p>你可以定义一个数组 <strong>归约后</strong> 的值，然后应用以下操作： <code>val = fn(init, nums[0])</code> ， <code>val = fn(val, nums[1])</code> ， <code>val = fn(val, nums[2])</code> ，<code>...</code> 直到数组中的每个元素都被处理完毕。返回 <code>val</code> 的最终值。</p>
<p>如果数组的长度为 0，它应该返回 <code>init</code> 的值。</p>
<p>请你在不使用内置数组方法的 <code>Array.reduce</code> 前提下解决这个问题。</p>
<h3 id="题解-8"><a href="#题解-8" class="headerlink" title="题解"></a>题解</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Fn</span> = <span class="function">(<span class="params">accum: <span class="built_in">number</span>, curr: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reduce</span>(<span class="params">nums: <span class="built_in">number</span>[], fn: Fn, init: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    nums.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">        init = <span class="title function_">fn</span>(init, value);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> init;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2627-函数防抖"><a href="#2627-函数防抖" class="headerlink" title="2627.函数防抖"></a>2627.函数防抖</h2><h3 id="题解-9"><a href="#题解-9" class="headerlink" title="题解"></a>题解</h3><p><strong>fn.apply的时候直接用this和args就行。</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> F = <span class="function">(<span class="params">...p: <span class="built_in">any</span>[]</span>) =&gt;</span> <span class="built_in">any</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn: F, t: <span class="built_in">number</span></span>): F &#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(timer) &#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        &#125;</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args), t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * const log = debounce(console.log, 100);</span></span><br><span class="line"><span class="comment"> * log(&#x27;Hello&#x27;); // cancelled</span></span><br><span class="line"><span class="comment"> * log(&#x27;Hello&#x27;); // cancelled</span></span><br><span class="line"><span class="comment"> * log(&#x27;Hello&#x27;); // Logged at t=100ms</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="2628-完全相等的-JSON-字符串"><a href="#2628-完全相等的-JSON-字符串" class="headerlink" title="2628.完全相等的 JSON 字符串"></a>2628.完全相等的 JSON 字符串</h2><p>给定两个对象 <code>o1</code> 和 <code>o2</code> ，请你检查它们是否 <strong>完全相等</strong> 。</p>
<p>对于两个 <strong>完全相等</strong> 的对象，它们必须包含相同的键，并且相关的值也必须 <strong>完全相等</strong> 。如果两个对象通过了 <code>===</code> 相等性检查，它们也被认为是 <strong>完全相等</strong> 的。</p>
<p>你可以假设这两个对象都是 <code>JSON.parse</code> 的输出。换句话说，它们是有效的 <code>JSON</code> 。</p>
<p>请你在不使用 lodash 的 <code>_.isEqual()</code> 函数的前提下解决这个问题。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：o1 = &#123;&quot;x&quot;:1,&quot;y&quot;:2&#125;, o2 = &#123;&quot;x&quot;:1,&quot;y&quot;:2&#125;</span><br><span class="line">输出：true</span><br><span class="line">输入：键和值完全匹配。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：o1 = &#123;&quot;y&quot;:2,&quot;x&quot;:1&#125;, o2 = &#123;&quot;x&quot;:1,&quot;y&quot;:2&#125;</span><br><span class="line">输出：true</span><br><span class="line">解释：尽管键的顺序不同，但它们仍然完全匹配。</span><br></pre></td></tr></table></figure>

<h3 id="题解-10"><a href="#题解-10" class="headerlink" title="题解"></a>题解</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">areDeeplyEqual</span>(<span class="params">o1: <span class="built_in">any</span>, o2: <span class="built_in">any</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(o1) !== <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(o2)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(o1 !== <span class="literal">null</span> &amp;&amp; <span class="keyword">typeof</span> o1 === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(o1).<span class="property">length</span> === <span class="title class_">Object</span>.<span class="title function_">keys</span>(o2).<span class="property">length</span> &amp;&amp; </span><br><span class="line">            <span class="title class_">Object</span>.<span class="title function_">entries</span>(o1).<span class="title function_">every</span>(</span><br><span class="line">                <span class="function">(<span class="params">[key, value]</span>) =&gt;</span> <span class="title function_">areDeeplyEqual</span>(value, o2[key])</span><br><span class="line">            )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o1 === o2</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Object-entries（）"><a href="#Object-entries（）" class="headerlink" title="Object.entries（）"></a>Object.entries（）</h3><p>entries() 方法返回一个新的Array Iterator对象，该对象包含数组中每个索引的键&#x2F;值对。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123; foo: &#x27;bar&#x27;, baz: 42 &#125;;</span><br><span class="line">Object.entries(obj)</span><br><span class="line">//输出 [ [&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 42] ]</span><br></pre></td></tr></table></figure>

<h2 id="2629-复合函数"><a href="#2629-复合函数" class="headerlink" title="2629.复合函数"></a>2629.复合函数</h2><p>请你编写一个函数，它接收一个函数数组 <code>[f1, f2, f3，…， fn]</code> ，并返回一个新的函数 <code>fn</code> ，它是函数数组的 <strong>复合函数</strong> 。</p>
<p><code>[f(x)， g(x)， h(x)]</code> 的 <strong>复合函数</strong> 为 <code>fn(x) = f(g(h(x)))</code> 。</p>
<p>一个空函数列表的 <strong>复合函数</strong> 是 <strong>恒等函数</strong> <code>f(x) = x</code> 。</p>
<p>你可以假设数组中的每个函数接受一个整型参数作为输入，并返回一个整型作为输出。</p>
<h3 id="题解-11"><a href="#题解-11" class="headerlink" title="题解"></a>题解</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> F = <span class="function">(<span class="params">x: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">compose</span>(<span class="params">functions: F[]</span>): F &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> functions.<span class="title function_">reduceRight</span>(<span class="function">(<span class="params">prev, fn</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">fn</span>(prev)</span><br><span class="line">        &#125;, x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * const fn = compose([x =&gt; x + 1, x =&gt; 2 * x])</span></span><br><span class="line"><span class="comment"> * fn(4) // 9</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="reduceRight"><a href="#reduceRight" class="headerlink" title="reduceRight()"></a>reduceRight()</h3><p><code>reduceRight</code> 方法用于从数组的最后一个元素开始，从右到左地对数组的元素进行迭代操作，并根据提供的回调函数来累积结果。在回调函数中，第一个参数是累加器（初始值为最后一个元素），第二个参数是当前正在处理的元素。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sum = numbers.<span class="title function_">reduceRight</span>(<span class="function">(<span class="params">accumulator, currentValue</span>) =&gt;</span> accumulator + currentValue);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sum); <span class="comment">// Output: 15</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> concatenated = numbers.<span class="title function_">reduceRight</span>(<span class="function">(<span class="params">accumulator, currentValue</span>) =&gt;</span> <span class="string">`<span class="subst">$&#123;accumulator&#125;</span>-<span class="subst">$&#123;currentValue&#125;</span>`</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(concatenated); <span class="comment">// Output: 5-4-3-2-1</span></span><br></pre></td></tr></table></figure>

<h2 id="2630-记忆函数（二）"><a href="#2630-记忆函数（二）" class="headerlink" title="2630.记忆函数（二）"></a>2630.记忆函数（二）</h2><p>现给定一个函数 <code>fn</code> ，返回该函数的一个 <strong>记忆化</strong> 版本。</p>
<p>一个 <strong>记忆化</strong> 的函数是一个函数，它不会被相同的输入调用两次。而是会返回一个缓存的值。</p>
<p>函数 <code>fn</code> 可以是任何函数，对它所接受的值类型没有任何限制。如果两个输入值在 JavaScript 中使用 <code>===</code> 运算符比较时相等，则它们被视为相同。</p>
<h3 id="与（一）的区别"><a href="#与（一）的区别" class="headerlink" title="与（一）的区别"></a>与（一）的区别</h3><p>（一）单纯比较传入参数是否相同，其中{}和{}判断为一种参数，实际上两个对象是不同的。所以这里不能再单纯的使用字符串来进行比较。</p>
<h3 id="题解-12"><a href="#题解-12" class="headerlink" title="题解"></a>题解</h3><h4 id="方法一-双Map"><a href="#方法一-双Map" class="headerlink" title="方法一 双Map"></a>方法一 双Map</h4><p>使用一个map来将args作为key来存储，另一个map存储函数的运行结果。使用map自带的has来判断传入的引用数据类型是否相同，因为这时他们比较的是地址。</p>
<p>把每一个参数用<code>Map</code>存储，并赋予一个不重复的ID，最简单的实现就是ID自增即可。然后把每个ID串起来成为字符串去另外一个<code>Map</code>里面查询这个ID组合是否存在过。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Function</span>&#125; <span class="variable">fn</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">memoize</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> argMap = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">const</span> argsMap = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">let</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> key = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> args) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!argMap.<span class="title function_">has</span>(item)) argMap.<span class="title function_">set</span>(item, id++);</span><br><span class="line">            key += argMap.<span class="title function_">get</span>(item) + <span class="string">&quot;-&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (argsMap.<span class="title function_">has</span>(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> argsMap.<span class="title function_">get</span>(key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title function_">fn</span>(...args);</span><br><span class="line">            argsMap.<span class="title function_">set</span>(key, res);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法二-前缀字典树"><a href="#方法二-前缀字典树" class="headerlink" title="方法二 前缀字典树"></a>方法二 前缀字典树</h4><blockquote>
<p>把[…args]看做一个连续的查询，每次查询都是一个新的字典（Map），这样只要其中一个查询跟已有的路径不一样都会产生新的字典（查询路径）。</p>
<p>具体实现还需要考虑最后结果的储存，因为字典只能解决不同查询对应不同的路径，但查询结束后需要有个地方找到之前已经存在的值，在路径查询结束后，查询一下是否存在旧值，如果有，返回旧值，如果没有，调用方法解算值并存储，具体有3种实现路径：</p>
<p>把结果当做一次查询放在最后的最后，只是这个查询都是用同样的名字，可以是一个特定的对象，可以是一个不可能出现的字符串，更便捷的是用Symbol()生成一个独一无二对象，然后以此作为最后的结果存在最后的Map里面；<br>用一个对象把Map和结果打包起来，类似这样{map: new Map(), result: undefined}，最后查询result是否等于undefined就知道是否有旧值了，这样相对比较简单，但需要使用额外的空间存放很多多余的对象；<br>第三种方案其实和第二种是一样的，只是具体手法不一样，可以扩展Map或者继承Map并添加一个result属性，在class关键词操作下代码量较少。当前了如果不是真实工程文件，可以直接在最后的Map对象上挂一个”野“属性map._result &#x3D; res，也是可以，不过不是正路，不做具体讨论；</p>
</blockquote>
<p>实际上就是将传入的参数生成一个树，并且给每个节点赋予一个属性<code>result</code>，如果没有这个节点则生成节点，有节点则判断是否有属性<code>result</code>，有的话直接取值，不需要再次执行函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DictNode</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Map</span>&#123;</span><br><span class="line">    <span class="comment">// 题目测试用例所以得到的结果都没有undefined，如果题目表示结果可能是任务值，改方法需要多增加一个变量save=false，用于判断查询路径的末端是否已经存在过旧值</span></span><br><span class="line">    res = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123; <span class="variable language_">super</span>() &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">memoize</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> root = <span class="keyword">new</span> <span class="title class_">DictNode</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> dict = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> args) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dict.<span class="title function_">has</span>(item)) dict.<span class="title function_">set</span>(item, <span class="keyword">new</span> <span class="title class_">DictNode</span>());</span><br><span class="line">            dict = dict.<span class="title function_">get</span>(item);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dict.<span class="property">res</span> === <span class="literal">undefined</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title function_">fn</span>(...args);</span><br><span class="line">            <span class="comment">// 这样操作其实跟野属性没有区别，更好的方法是加一个方法用于修改这个`.res`值</span></span><br><span class="line">            dict.<span class="property">res</span> = res;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> dict.<span class="property">res</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2631-分组函数"><a href="#2631-分组函数" class="headerlink" title="2631.分组函数"></a>2631.分组函数</h2><p>请你编写一段可应用于所有数组的代码，使任何数组调用 <code>array. groupBy(fn)</code> 方法时，它返回对该数组 <strong>分组后</strong> 的结果。</p>
<p>数组 <strong>分组</strong> 是一个对象，其中的每个键都是 <code>fn(arr[i])</code> 的输出的一个数组，该数组中含有原数组中具有该键的所有项。</p>
<p>提供的回调函数 <code>fn</code> 将接受数组中的项并返回一个字符串类型的键。</p>
<p>每个值列表的顺序应该与元素在数组中出现的顺序相同。任何顺序的键都是可以接受的。</p>
<p>请在不使用 lodash 的 <code>_.groupBy</code> 函数的前提下解决这个问题。</p>
<h3 id="题解-13"><a href="#题解-13" class="headerlink" title="题解"></a>题解</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable language_">global</span> &#123;</span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Array</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="title function_">groupBy</span>(<span class="attr">fn</span>: <span class="function">(<span class="params">item: T</span>) =&gt;</span> <span class="built_in">string</span>): <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, T[]&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">groupBy</span> = <span class="keyword">function</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">ans</span>: <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="built_in">any</span>[]&gt; = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> <span class="variable language_">this</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> res = <span class="title function_">fn</span>(item);</span><br><span class="line">        <span class="comment">// res是执行fn后返回的键， ans中没有res键则建一个，有的话直接添加元素</span></span><br><span class="line">        (ans[res] ?? (ans[res] = [])).<span class="title function_">push</span>(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * [1,2,3].groupBy(String) // &#123;&quot;1&quot;:[1],&quot;2&quot;:[2],&quot;3&quot;:[3]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="2632-柯里化"><a href="#2632-柯里化" class="headerlink" title="2632.柯里化"></a>2632.柯里化</h2><p>请你编写一个函数，它接收一个其他的函数，并返回该函数的 <strong>柯里化</strong> 后的形式。</p>
<p><strong>柯里化</strong> 函数的定义是接受与原函数相同数量或更少数量的参数，并返回另一个 <strong>柯里化</strong> 后的函数或与原函数相同的值。</p>
<p>实际上，当你调用原函数，如 <code>sum(1,2,3)</code> 时，它将调用 <strong>柯里化</strong> 函数的某个形式，如 <code>csum(1)(2)(3)</code>， <code>csum(1)(2,3)</code>， <code>csum(1,2)(3)</code>，或 <code>csum(1,2,3)</code> 。所有调用 <strong>柯里化</strong> 函数的方法都应该返回与原始函数相同的值。</p>
<h3 id="题解-14"><a href="#题解-14" class="headerlink" title="题解"></a>题解</h3><p>凡是依赖curried函数外部闭包变量保存参数值的做法虽然能通过测试，但都存在不能复用中间函数的问题 正确思路：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">curry</span>(<span class="params">fn: <span class="built_in">Function</span></span>): <span class="title class_">Function</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">curried</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> f = fn.<span class="title function_">bind</span>(<span class="literal">undefined</span>, ...args);</span><br><span class="line">        <span class="keyword">if</span>(f.<span class="property">length</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="title function_">f</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">curry</span>(f);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">curry</span>(<span class="params">fn</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">curried</span>(<span class="params">...args</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (args.<span class="property">length</span> &gt;= fn.<span class="property">length</span>) <span class="keyword">return</span> <span class="title function_">fn</span>(...args)</span><br><span class="line">        <span class="keyword">return</span> <span class="function">(<span class="params">...args2</span>) =&gt;</span> <span class="title function_">curried</span>(...args, ...args2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2633-将对象转换为JSON字符串"><a href="#2633-将对象转换为JSON字符串" class="headerlink" title="2633.将对象转换为JSON字符串"></a>2633.将对象转换为JSON字符串</h2><p>现给定一个对象，返回该对象的有效 JSON 字符串。你可以假设这个对象只包括字符串、整数、数组、对象、布尔值和 null。返回的字符串不能包含额外的空格。键的返回顺序应该与 <code>Object.keys()</code> 的顺序相同。</p>
<p>请你在不使用内置方法 <code>JSON.stringify</code> 的前提下解决这个问题。</p>
<h3 id="题解-15"><a href="#题解-15" class="headerlink" title="题解"></a>题解</h3><p>因为传入的一定是一个对象，所以首先遍历的一定是对象，所以即使对象中包含的是基本数据类型，那么也是会先进行一次<strong>第1种情况</strong>的流程，然后将键值分开转换。</p>
<p>共分四种情况：</p>
<ol>
<li>对象：递归遍历对象中的属性，并且将键和值都转换为字符串，外面包裹一个<code>&#123;&#125;</code>；</li>
<li>数组：递归遍历数组中的元素，不需要保留数组的index，只需要将值变为字符串，外面包裹一个<code>[]</code>;</li>
<li>null：返回字符串’null’；</li>
<li>字符串：返回带 “” 的字符串值；</li>
<li>基本数据类型：返回字符串化的基本数据类型。</li>
</ol>
<p><strong>注意判断顺序，</strong>null和array也属于object。所以要先判断null和array再判断object。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">jsonStringify</span>(<span class="params"><span class="built_in">object</span>: <span class="built_in">any</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">object</span> === <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;null&quot;</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(<span class="built_in">object</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`[<span class="subst">$&#123;<span class="built_in">object</span>.map(jsonStringify).join(<span class="string">&quot;,&quot;</span>)&#125;</span>]`</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="built_in">object</span> === <span class="string">&quot;object&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`&#123;<span class="subst">$&#123;<span class="built_in">Object</span>.keys(<span class="built_in">object</span>).map(key =&gt; <span class="string">`&quot;<span class="subst">$&#123;key&#125;</span>&quot;:<span class="subst">$&#123;jsonStringify(<span class="built_in">object</span>[key])&#125;</span>`</span>)&#125;</span>&#125;`</span> </span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="built_in">object</span> === <span class="string">&quot;string&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`&quot;<span class="subst">$&#123;<span class="built_in">object</span>&#125;</span>&quot;`</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">String</span>(<span class="built_in">object</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2634-过滤数组中的元素"><a href="#2634-过滤数组中的元素" class="headerlink" title="2634.过滤数组中的元素"></a>2634.过滤数组中的元素</h2><p>请你编写一个函数，该函数接受一个整数数组参数 <code>arr</code> 和一个过滤函数 <code>fn</code>，并返回一个过滤后元素数量较少或元素数量相等的新数组。</p>
<p>返回的数组应该只包含通过过滤函数 <code>fn(arr[i]， i)</code> 计算后为真值的元素。</p>
<p>请你在不使用内置函数 <code>Array.filter</code> 的前提下解决该问题。</p>
<h3 id="题解-16"><a href="#题解-16" class="headerlink" title="题解"></a>题解</h3><p>总体都是遍历的思路。</p>
<h4 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">filter</span>(<span class="params">arr: <span class="built_in">number</span>[], fn: (n: <span class="built_in">number</span>, i: <span class="built_in">number</span>) =&gt; <span class="built_in">any</span></span>): <span class="built_in">number</span>[] &#123;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_">fn</span>(item, index))</span><br><span class="line">            res.<span class="title function_">push</span>(item)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> filter = <span class="keyword">function</span>(<span class="params">arr, fn</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">pre, cur,index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">fn</span>(cur,index)) &#123;</span><br><span class="line">            pre.<span class="title function_">push</span>(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;, [])</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2635-转换数组中的每个元素"><a href="#2635-转换数组中的每个元素" class="headerlink" title="2635.转换数组中的每个元素"></a>2635.转换数组中的每个元素</h2><p>编写一个函数，这个函数接收一个整数数组 <code>arr</code> 和一个映射函数 <code>fn</code> ，通过该映射函数返回一个新的数组。</p>
<p>返回数组的创建语句应为 <code>returnedArray[i] = fn(arr[i], i)</code> 。</p>
<p>请你在不使用内置方法 <code>Array.map</code> 的前提下解决这个问题。</p>
<h3 id="题解-17"><a href="#题解-17" class="headerlink" title="题解"></a>题解</h3><h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">map</span>(<span class="params">arr: <span class="built_in">number</span>[], fn: (n: <span class="built_in">number</span>, i: <span class="built_in">number</span>) =&gt; <span class="built_in">number</span></span>): <span class="built_in">number</span>[] &#123;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        res.<span class="title function_">push</span>(<span class="title function_">fn</span>(arr[i], i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="reduce-1"><a href="#reduce-1" class="headerlink" title="reduce"></a>reduce</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">function</span>(<span class="params">arr, fn</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">p, c, i</span>) =&gt;</span> (p.<span class="title function_">push</span>(fn.<span class="title function_">apply</span>(<span class="literal">null</span>, [c, i])),p) , [])</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="from"><a href="#from" class="headerlink" title="from"></a>from</h4><p>转换类数组为数组的同时，可以进行类似map的操作，返回值为一个新数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">function</span>(<span class="params">arr, fn</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(arr, fn);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2636-Promise对象池"><a href="#2636-Promise对象池" class="headerlink" title="2636.Promise对象池"></a>2636.Promise对象池</h2><p>请你编写一个异步函数 <code>promisePool</code> ，它接收一个异步函数数组 <code>functions</code> 和 <strong>池限制</strong> <code>n</code>。它应该返回一个 promise 对象，当所有输入函数都执行完毕后，promise 对象就执行完毕。</p>
<p><strong>池限制</strong> 定义是一次可以挂起的最多 promise 对象的数量。<code>promisePool</code> 应该开始执行尽可能多的函数，并在旧的 promise 执行完毕后继续执行新函数。<code>promisePool</code> 应该先执行 <code>functions[i]</code>，再执行 <code>functions[i + 1]</code>，然后执行 <code>functions[i + 2]</code>，等等。当最后一个 promise 执行完毕时，<code>promisePool</code> 也应该执行完毕。</p>
<p>例如，如果 <code>n = 1</code> , <code>promisePool</code> 在序列中每次执行一个函数。然而，如果 <code>n = 2</code> ，它首先执行两个函数。当两个函数中的任何一个执行完毕后，再执行第三个函数(如果它是可用的)，依此类推，直到没有函数要执行为止。</p>
<p>你可以假设所有的 <code>functions</code> 都不会被拒绝。对于 <code>promisePool</code> 来说，返回一个可以解析任何值的 promise 都是可以接受的。</p>
<h3 id="题解-18"><a href="#题解-18" class="headerlink" title="题解"></a>题解</h3><p>跟TaskQueue的题很像，大致思路是搞个函数每次从queue里取一个执行，如果还有queue就自动执行下一个。 然后开始的时候同时调用n次这个函数就好了。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> F = <span class="function">() =&gt;</span> <span class="title class_">Promise</span>&lt;<span class="built_in">any</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">promisePool</span>(<span class="params">functions: F[], n: <span class="built_in">number</span></span>): <span class="title class_">Promise</span>&lt;<span class="built_in">any</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> remaining = [...functions];</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(remaining.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> fn = remaining.<span class="title function_">shift</span>();</span><br><span class="line">            <span class="keyword">await</span> <span class="title function_">fn</span>();</span><br><span class="line">            <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> tasks = functions.<span class="title function_">slice</span>(<span class="number">0</span>, n).<span class="title function_">map</span>(next);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(tasks);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promisePool = <span class="keyword">async</span> <span class="keyword">function</span>(<span class="params">functions, n</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">next</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (functions.<span class="property">length</span>) <span class="keyword">await</span> functions.<span class="title function_">shift</span>()();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>([...<span class="title class_">Array</span>(n)].<span class="title function_">map</span>(next));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promisePool = <span class="keyword">async</span> <span class="keyword">function</span>(<span class="params">functions, n</span>) &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>([...<span class="keyword">new</span> <span class="title class_">Array</span>(n)].<span class="title function_">map</span>(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (functions.<span class="property">length</span>) &#123;</span><br><span class="line">            <span class="keyword">await</span> functions.<span class="title function_">shift</span>()()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;))</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Function[]</span>&#125; <span class="variable">functions</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">Function</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> promisePool = <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params">functions, n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> iter = functions.<span class="title function_">values</span>()</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">worker</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> work <span class="keyword">of</span> iter) &#123;</span><br><span class="line">            <span class="keyword">await</span> <span class="title function_">work</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">allSettled</span>(<span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>().<span class="title function_">map</span>(worker))</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2637-有时间限制的Promise对象"><a href="#2637-有时间限制的Promise对象" class="headerlink" title="2637.有时间限制的Promise对象"></a>2637.有时间限制的Promise对象</h2><p>请你编写一个函数，它接收一个异步函数 <code>fn</code> 和一个以毫秒为单位的时间 <code>t</code>。它应根据限时函数返回一个有 <strong>限时</strong> 效果的函数。</p>
<p>限时函数是与原函数相同的函数，除非它需要 <code>t</code> 毫秒以上的时间来完成。如果出现了这种情况，请你返回 <code>&quot;Time Limit Exceeded&quot;</code> 拒绝这次函数的调用。注意，它应该返回一个字符串拒绝，而不是一个 <code>Error</code> 。</p>
<h3 id="题解-19"><a href="#题解-19" class="headerlink" title="题解"></a>题解</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Fn</span> = <span class="function">(<span class="params">...params: <span class="built_in">any</span>[]</span>) =&gt;</span> <span class="title class_">Promise</span>&lt;<span class="built_in">any</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">timeLimit</span>(<span class="params">fn: Fn, t: <span class="built_in">number</span></span>): <span class="title class_">Fn</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">async</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> timer;</span><br><span class="line">        <span class="keyword">const</span> timeoutPromise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">res,rej</span>) =&gt;</span> &#123;</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">rej</span>(<span class="string">&#x27;Time Limit Exceeded&#x27;</span>), t)</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">race</span>([<span class="title function_">fn</span>(...args),timeoutPromise]).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2648-生成斐波那契数列"><a href="#2648-生成斐波那契数列" class="headerlink" title="2648.生成斐波那契数列"></a>2648.生成斐波那契数列</h2><p>请你编写一个生成器函数，并返回一个可以生成 <strong>斐波那契数列</strong> 的生成器对象。</p>
<p><strong>斐波那契数列</strong> 的递推公式为 <code>Xn = Xn-1 + Xn-2</code> 。</p>
<p>这个数列的前几个数字是 <code>0, 1, 1, 2, 3, 5, 8, 13</code> 。</p>
<h3 id="题解-20"><a href="#题解-20" class="headerlink" title="题解"></a>题解</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">fibGenerator</span>(): <span class="title class_">Generator</span>&lt;<span class="built_in">number</span>, <span class="built_in">any</span>, <span class="built_in">number</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">yield</span> a;</span><br><span class="line">        [a, b] = [b, a + b];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * const gen = fibGenerator();</span></span><br><span class="line"><span class="comment"> * gen.next().value; // 0</span></span><br><span class="line"><span class="comment"> * gen.next().value; // 1</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">fibGenerator</span>(): <span class="title class_">Generator</span>&lt;<span class="built_in">number</span>, <span class="built_in">any</span>, <span class="built_in">number</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> dp = <span class="title class_">Array</span>(<span class="number">51</span>);</span><br><span class="line">  dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= <span class="number">50</span>; i++) &#123;</span><br><span class="line">    dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(dp.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> dp.<span class="title function_">shift</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2649-嵌套数组生成器"><a href="#2649-嵌套数组生成器" class="headerlink" title="2649.嵌套数组生成器"></a>2649.嵌套数组生成器</h2><p>现给定一个整数的 <strong>多维数组</strong> ，请你返回一个生成器对象，按照 <strong>中序遍历</strong> 的顺序逐个生成整数。</p>
<p><strong>多维数组</strong> 是一个递归数据结构，包含整数和其他 <strong>多维数组</strong>。</p>
<p><strong>中序遍历</strong> 是从左到右遍历每个数组，在遇到任何整数时生成它，遇到任何数组时递归应用 <strong>中序遍历</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [[[6]],[1,3],[]]</span><br><span class="line">输出：[6,1,3]</span><br><span class="line">解释：</span><br><span class="line">const generator = inorderTraversal(arr);</span><br><span class="line">generator.next().value; // 6</span><br><span class="line">generator.next().value; // 1</span><br><span class="line">generator.next().value; // 3</span><br><span class="line">generator.next().done; // true</span><br></pre></td></tr></table></figure>

<h3 id="题解-21"><a href="#题解-21" class="headerlink" title="题解"></a>题解</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MultidimensionalArray</span> = (<span class="title class_">MultidimensionalArray</span> | <span class="built_in">number</span>)[]</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">inorderTraversal</span>(<span class="attr">arr</span>: <span class="title class_">MultidimensionalArray</span>): <span class="title class_">Generator</span>&lt;<span class="built_in">number</span>, <span class="built_in">void</span>, <span class="built_in">unknown</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(item)) &#123;</span><br><span class="line">            <span class="keyword">yield</span>* <span class="title function_">inorderTraversal</span>(item)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">yield</span> item</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * const gen = inorderTraversal([1, [2, 3]]);</span></span><br><span class="line"><span class="comment"> * gen.next().value; // 1</span></span><br><span class="line"><span class="comment"> * gen.next().value; // 2</span></span><br><span class="line"><span class="comment"> * gen.next().value; // 3</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="2650-设计可取消的函数-hard"><a href="#2650-设计可取消的函数-hard" class="headerlink" title="2650.设计可取消的函数(hard)"></a>2650.设计可取消的函数(hard)</h2><p>有时候你会有一个长时间运行的任务，并且你可能希望在它完成之前取消它。为了实现这个目标，请你编写一个名为 <code>cancellable</code> 的函数，它接收一个生成器对象，并返回一个包含两个值的数组：一个 <strong>取消函数</strong> 和一个 <strong>promise</strong> 对象。</p>
<p>你可以假设生成器函数只会生成 promise 对象。你的函数负责将 promise 对象解析的值传回生成器。如果 promise 被拒绝，你的函数应将该错误抛回给生成器。</p>
<p>如果在生成器完成之前调用了取消回调函数，则你的函数应该将错误抛回给生成器。该错误应该是字符串 <code>&quot;Cancelled&quot;</code>（而不是一个 <code>Error</code> 对象）。如果错误被捕获，则返回的 promise 应该解析为下一个生成或返回的值。否则，promise 应该被拒绝并抛出该错误。不应执行任何其他代码。</p>
<p>当生成器完成时，您的函数返回的 promise 应该解析为生成器返回的值。但是，如果生成器抛出错误，则返回的 promise 应该拒绝并抛出该错误。</p>
<p>下面是您的代码应如何使用的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function* tasks() &#123;</span><br><span class="line">  const val = yield new Promise(resolve =&gt; resolve(2 + 2));</span><br><span class="line">  yield new Promise(resolve =&gt; setTimeout(resolve, 100));</span><br><span class="line">  return val + 1; // calculation shouldn&#x27;t be done.</span><br><span class="line">&#125;</span><br><span class="line">const [cancel, promise] = cancellable(tasks());</span><br><span class="line">setTimeout(cancel, 50);</span><br><span class="line">promise.catch(console.log); // logs &quot;Cancelled&quot; at t=50ms</span><br></pre></td></tr></table></figure>

<p>如果相反， <code>cancel()</code> 没有被调用或者在 <code>t=100ms</code> 之后才被调用，那么 Promise 应被解析为 <code>5</code> 。</p>
<h3 id="题解-22"><a href="#题解-22" class="headerlink" title="题解"></a>题解</h3><h4 id="1-什么是-generator-？："><a href="#1-什么是-generator-？：" class="headerlink" title="1.什么是 generator ？："></a>1.什么是 generator ？：</h4><p>简单的说就是可以中断的函数，该函数里的代码可以用 yield 关键字来中断。如何继续执行？看下面</p>
<h4 id="2-怎么定义一个-generator-："><a href="#2-怎么定义一个-generator-：" class="headerlink" title="2.怎么定义一个 generator ："></a>2.怎么定义一个 generator ：</h4><p>一般来说都用 function* 标识符来定义，例如</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">tasks</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> val = <span class="keyword">yield</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="title function_">resolve</span>(<span class="number">2</span> + <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">100</span>));</span><br><span class="line">    <span class="keyword">return</span> val + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-generator-的实例，或者说返回值，有哪些方法？"><a href="#3-generator-的实例，或者说返回值，有哪些方法？" class="headerlink" title="3.generator 的实例，或者说返回值，有哪些方法？"></a>3.generator 的实例，或者说返回值，有哪些方法？</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">tasks</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> val = <span class="keyword">yield</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="title function_">resolve</span>(<span class="number">2</span> + <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">100</span>));</span><br><span class="line">    <span class="keyword">return</span> val + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> _t = <span class="title function_">tasks</span>();</span><br></pre></td></tr></table></figure>

<p>总的来说有三种方法，next、throw, return。这三种方法都会返回一个 IteratorResult，也就是形如：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IteratorResult</span> &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="built_in">any</span>;</span><br><span class="line">    <span class="attr">done</span>: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>done 则表示该 generator 是否完成，true 完成，false 未完成</p>
</li>
<li><p>value 不同方法调用代表的值不同，下面再说。</p>
</li>
</ul>
<p>那么 generator 啥时候完成？就是走到这个 generator 本身 return 的时候。</p>
<p>下面开始介绍三个方法</p>
<ul>
<li><p>next 方法：</p>
<ul>
<li><p>在 next 方法的返回值中，IteratorResult 中的 value 是 yield 关键词右侧代码的执行结果</p>
</li>
<li><p>generator 的执行必需由 next 方法开启，并走到 yield 关键词停止</p>
</li>
<li><p>继续调用next() 可以在 yield 后继续往下走，走到下一个 yield 为止</p>
</li>
<li><p>该方法同时支持传参，传入的参数会成为上一个 yield 的返回值，例如：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">tasks</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> val = <span class="keyword">yield</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="title function_">resolve</span>(<span class="number">2</span> + <span class="number">2</span>)); <span class="comment">// 1</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;val&#125;);</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">100</span>)); <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> val + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> _t = <span class="title function_">tasks</span>();</span><br><span class="line">_t.<span class="title function_">next</span>(); <span class="comment">// 走到 1 处，返回的 &#123;value， done&#125; 中的 value 是 1 处的 Promise</span></span><br><span class="line">_t.<span class="title function_">next</span>(<span class="number">100</span>); <span class="comment">// 走到 2 处，打印 val 为 100</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>throw 方法：</p>
<ul>
<li><p>在 throw 方法的返回值中，IteratorResult 中的 value 同样是 yield 关键词右侧代码的执行结果</p>
</li>
<li><p>该方法通过传参抛出一个错误，如果该错误没有被 generator 本身 catch 住，则会往外暴露给外层，也就是 generator 的调用方。如果调用方也没有 catch 住，则正常抛错。</p>
</li>
<li><p>例子1，被 generator 本身 catch：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">tasks</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> val = <span class="keyword">yield</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="title function_">resolve</span>(<span class="number">2</span> + <span class="number">2</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;catched by generator *tasks&#x27;</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">100</span>));</span><br><span class="line">    <span class="keyword">return</span> val + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> _t = <span class="title function_">tasks</span>();</span><br><span class="line">_t.<span class="title function_">next</span>();</span><br><span class="line">_t.<span class="keyword">throw</span>(<span class="string">&#x27;err 1&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>例子2，被 generator 的调用方 catch：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">tasks</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> val = <span class="keyword">yield</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="title function_">resolve</span>(<span class="number">2</span> + <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">100</span>));</span><br><span class="line">    <span class="keyword">return</span> val + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> _t = <span class="title function_">tasks</span>();</span><br><span class="line">_t.<span class="title function_">next</span>();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    _t.<span class="keyword">throw</span>(<span class="string">&#x27;err 2&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;catched by generator *tasks caller&#x27;</span>, err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>return 方法</p>
<ul>
<li><p>在 return 方法的返回值中，IteratorResult 中的 value 同样是 return 方法传递的参数</p>
</li>
<li><p>该方法强制 generator 函数完成，其返回 IteratorResult 中的 done 将为 true</p>
</li>
<li><p>举例</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">tasks</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> val = <span class="keyword">yield</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="title function_">resolve</span>(<span class="number">2</span> + <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">100</span>));</span><br><span class="line">    <span class="keyword">return</span> val + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> _t = <span class="title function_">tasks</span>();</span><br><span class="line">_t.<span class="title function_">next</span>();</span><br><span class="line"><span class="keyword">const</span> obj = _t.<span class="keyword">return</span>(<span class="string">&#x27;Return by Generator.return method&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj); <span class="comment">// &#123;value: &#x27;Return by Generator.return method&#x27;, done: true&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="4-回到本题"><a href="#4-回到本题" class="headerlink" title="4.回到本题"></a>4.回到本题</h4><ol>
<li>首先得返回一个数组，一个是 function，一个是 Promise</li>
<li>其次我们要走完这个 generator 得不停的调用 next 方法。一般用 while 或者递归，这里我们涉及传参给下一个调用，所以要用递归</li>
<li>我们有个 cancel 方法，根据题意，这个方法显然是要用 throw 方法的，并且其失败被 generator 调用方 捕获时，要直接 reject 这个 Promise。所以要利用闭包定义在 Promise 中</li>
<li>generator 内部调用的 Promise 可能成功也可能失败，所以要处理成功、失败两种情况。对于这个 Promise 来说，成功的回调我们走 next，失败的回调我们应该 throw</li>
<li>generator 本身会抛出一个错误，所以要对 next 的运行进行 try catch，根据题意 catch 后我们要直接 reject 掉这个 Promise</li>
</ol>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> cancellable&lt;T&gt;(<span class="attr">generator</span>: <span class="title class_">Generator</span>&lt;<span class="title class_">Promise</span>&lt;<span class="built_in">any</span>&gt;, T, <span class="built_in">unknown</span>&gt;): [<span class="function">() =&gt;</span> <span class="built_in">void</span>, <span class="title class_">Promise</span>&lt;T&gt;] &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">cancel</span> = (<span class="params"></span>) =&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>&lt;T&gt;(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        cancel = <span class="function">(<span class="params">msg = <span class="string">&#x27;Cancelled&#x27;</span></span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">run</span>(msg, <span class="string">&#x27;throw&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="title function_">run</span> = (<span class="params">ret, fnName = <span class="string">&#x27;next&#x27;</span></span>) =&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> &#123;value, done&#125; = generator[fnName](ret);</span><br><span class="line">                <span class="keyword">if</span>(done) &#123;</span><br><span class="line">                    <span class="title function_">resolve</span>(value);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                value.<span class="title function_">then</span>(<span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="title function_">run</span>(val);</span><br><span class="line">                &#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="title function_">run</span>(err, <span class="string">&#x27;throw&#x27;</span>);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; <span class="keyword">catch</span>(errorByGenerator) &#123;</span><br><span class="line">                <span class="title function_">reject</span>(errorByGenerator);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="title function_">run</span>(<span class="literal">null</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> [cancel, p];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * function* tasks() &#123;</span></span><br><span class="line"><span class="comment"> *   const val = yield new Promise(resolve =&gt; resolve(2 + 2));</span></span><br><span class="line"><span class="comment"> *   yield new Promise(resolve =&gt; setTimeout(resolve, 100));</span></span><br><span class="line"><span class="comment"> *   return val + 1;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * const [cancel, promise] = cancellable(tasks());</span></span><br><span class="line"><span class="comment"> * setTimeout(cancel, 50);</span></span><br><span class="line"><span class="comment"> * promise.catch(console.log); // logs &quot;Cancelled&quot; at t=50ms</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="2665-计数器II"><a href="#2665-计数器II" class="headerlink" title="2665.计数器II"></a>2665.计数器II</h2><p>请你写一个函数 <code>createCounter</code>. 这个函数接收一个初始的整数值 <code>init</code> 并返回一个包含三个函数的对象。</p>
<p>这三个函数是：</p>
<ul>
<li><code>increment()</code> 将当前值加 1 并返回。</li>
<li><code>decrement()</code> 将当前值减 1 并返回。</li>
<li><code>reset()</code> 将当前值设置为 <code>init</code> 并返回。</li>
</ul>
<h3 id="题解-23"><a href="#题解-23" class="headerlink" title="题解"></a>题解</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ReturnObj</span> = &#123;</span><br><span class="line">    <span class="attr">increment</span>: <span class="function">() =&gt;</span> <span class="built_in">number</span>,</span><br><span class="line">    <span class="attr">decrement</span>: <span class="function">() =&gt;</span> <span class="built_in">number</span>,</span><br><span class="line">    <span class="attr">reset</span>: <span class="function">() =&gt;</span> <span class="built_in">number</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createCounter</span>(<span class="params">init: <span class="built_in">number</span></span>): <span class="title class_">ReturnObj</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> n = init;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; ++n;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">reset</span> = (<span class="params"></span>) =&gt; n = init;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">decrement</span> = (<span class="params"></span>) =&gt; --n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;increment, decrement, reset&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * const counter = createCounter(5)</span></span><br><span class="line"><span class="comment"> * counter.increment(); // 6</span></span><br><span class="line"><span class="comment"> * counter.reset(); // 5</span></span><br><span class="line"><span class="comment"> * counter.decrement(); // 4</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h3><blockquote>
<p>const reset &#x3D; () &#x3D;&gt; n &#x3D; init;</p>
</blockquote>
<p>是可以直接n同时赋值并返回的。</p>
<h2 id="2666-只允许一次函数调用"><a href="#2666-只允许一次函数调用" class="headerlink" title="2666.只允许一次函数调用"></a>2666.只允许一次函数调用</h2><p>给定一个函数 <code>fn</code> ，它返回一个新的函数，返回的函数与原始函数完全相同，只不过它确保 <code>fn</code> 最多被调用一次。</p>
<ul>
<li>第一次调用返回的函数时，它应该返回与 <code>fn</code> 相同的结果。</li>
<li>第一次后的每次调用，它应该返回 <code>undefined</code> 。</li>
</ul>
<h3 id="题解-24"><a href="#题解-24" class="headerlink" title="题解"></a>题解</h3><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> once&lt;T <span class="keyword">extends</span> (...<span class="attr">args</span>: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span>&gt;(<span class="attr">fn</span>: T): </span><br><span class="line"> (<span class="function">(<span class="params">...args: Parameters&lt;T&gt;</span>) =&gt;</span> <span class="title class_">ReturnType</span>&lt;T&gt; | <span class="literal">undefined</span>) &#123;</span><br><span class="line">     <span class="keyword">let</span> hasUsed = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(hasUsed) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">          hasUsed = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, [...args])</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * let fn = (a,b,c) =&gt; (a + b + c)</span></span><br><span class="line"><span class="comment"> * let onceFn = once(fn)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * onceFn(1,2,3); // 6</span></span><br><span class="line"><span class="comment"> * onceFn(2,3,6); // returns undefined without calling fn</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h4 id="try…catch"><a href="#try…catch" class="headerlink" title="try…catch"></a>try…catch</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//finally的内容会在return后执行，在finally里面把fn换成空函数就可以了</span></span><br><span class="line"><span class="keyword">var</span> once = <span class="keyword">function</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">fn</span>(...args)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span>&#123;</span><br><span class="line">            fn=<span class="function">()=&gt;</span>&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="注意-3"><a href="#注意-3" class="headerlink" title="注意"></a>注意</h3><p>以下是对代码中 TypeScript 部分的解释：</p>
<ul>
<li><code>function once&lt;T extends (...args: any[]) =&gt; any&gt;(fn: T): ...</code>：这是 <code>once</code> 函数的定义。它使用了 TypeScript 的泛型 <code>&lt;T&gt;</code> 来表示函数的类型，并限制泛型类型 <code>T</code> 必须是一个函数类型，可以接受任意数量的参数并返回一个值。</li>
<li><code>(...args: Parameters&lt;T&gt;) =&gt; ReturnType&lt;T&gt; | undefined</code>：这是返回函数的类型定义。它使用了 TypeScript 的内置类型 <code>Parameters&lt;T&gt;</code> 来获取函数类型 <code>T</code> 的参数类型，并使用 <code>ReturnType&lt;T&gt;</code> 获取函数类型 <code>T</code> 的返回值类型。返回函数接受与 <code>fn</code> 相同的参数，并返回 <code>fn</code> 的返回值或 <code>undefined</code>。</li>
<li><code>return function (...args) &#123; ... &#125;</code>：这是返回函数的实现部分。返回的函数使用了剩余参数 <code>...args</code> 来接收任意数量的参数。在函数体内部，可以根据需要实现具体的逻辑。</li>
</ul>
<h2 id="2675-将对象数组转换为矩阵"><a href="#2675-将对象数组转换为矩阵" class="headerlink" title="2675.将对象数组转换为矩阵"></a>2675.将对象数组转换为矩阵</h2><p>编写一个函数，将对象数组 <code>arr</code> 转换为矩阵 <code>m</code> 。</p>
<p><code>arr</code> 是一个由对象组成的数组或一个数组。数组中的每个项都可以包含深层嵌套的子数组和子对象。它还可以包含数字、字符串、布尔值和空值。</p>
<p>矩阵 <code>m</code> 的第一行应该是列名。如果没有嵌套，列名是对象中的唯一键。如果存在嵌套，列名是对象中相应路径，以点号 <code>&quot;.&quot;</code> 分隔。</p>
<p>剩余的每一行对应 <code>arr</code> 中的一个对象。矩阵中的每个值对应对象中的一个值。如果给定对象在给定列中没有值，则应该包含空字符串 <code>&quot;&quot;</code> 。</p>
<p>矩阵中的列应按 <strong>字典升序</strong> 排列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">arr = [</span><br><span class="line">  &#123;&quot;b&quot;: 1, &quot;a&quot;: 2&#125;,</span><br><span class="line">  &#123;&quot;b&quot;: 3, &quot;a&quot;: 4&#125;</span><br><span class="line">]</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [&quot;a&quot;, &quot;b&quot;],</span><br><span class="line">  [2, 1],</span><br><span class="line">  [4, 3]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">两个对象中有两个唯一的列名：&quot;a&quot;和&quot;b&quot;。 </span><br><span class="line">&quot;a&quot;对应[2, 4]。 </span><br><span class="line">&quot;b&quot;对应[1, 3]。</span><br></pre></td></tr></table></figure>

<h3 id="题解-25"><a href="#题解-25" class="headerlink" title="题解"></a>题解</h3><h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><ul>
<li>Object.keys() 对对象操作，获得的是该对象的键数组。</li>
<li>Object.keys() 对数组操作，获得的是该数组的下标数组。</li>
</ul>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>首先需要递归地处理所有的Key，包括数组和对象的。将其存放到一个Map中，该Map负责将Key映射到下标。之后再递归地处理相应的值。</p>
<p><strong>1.处理Key（第一次递归）</strong></p>
<p>因为有对象嵌套对象，所以需要递归地处理。</p>
<p>o：当前遍历的对象（数组）；<br>prefix：key的前缀字符串。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">resolveHead</span>(<span class="params">o, prefix</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> k <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(o)) &#123;</span><br><span class="line">        <span class="comment">// 如果是可枚举类型就继续递归</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> o[k] === <span class="string">&quot;object&quot;</span> &amp;&amp; o[k] !== <span class="literal">null</span>)</span><br><span class="line">            <span class="title function_">resolveHead</span>(o[k], prefix + k + <span class="string">&quot;.&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            set.<span class="title function_">add</span>(prefix + k)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">o</span>) =&gt;</span> <span class="title function_">resolveHead</span>(o, <span class="string">&quot;&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>经过这一步递归处理，在set已经存放了所有的可能出现的键了。</p>
<p><strong>2.将set转换成map</strong><br>我们需要将键映射到下标，且set本身并不一定按字典升序排列，所以需要先排序，再存放到map中。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> titles = <span class="title class_">Array</span>.<span class="title function_">from</span>(set).<span class="title function_">sort</span>()</span><br><span class="line">result.<span class="title function_">push</span>(titles) <span class="comment">// 将其存放到第一行</span></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">titles.<span class="title function_">forEach</span>(<span class="function">(<span class="params">v, i</span>) =&gt;</span> map.<span class="title function_">set</span>(v, i))</span><br></pre></td></tr></table></figure>

<p><strong>3.处理每一行的结果（第二次递归）</strong></p>
<p>这个步骤逻辑几乎和第一遍处理key一样，只需要多传递一个row，以及将set.add(prefix + k)换成修改row中的元素即可。</p>
<p>o：当前遍历的对象（数组）；<br>prefix：key的前缀字符串；<br>row：当前处理的行。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">resolveRow</span>(<span class="params">o, prefix, row</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> k <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(o)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> o[k] === <span class="string">&quot;object&quot;</span> &amp;&amp; o[k] !== <span class="literal">null</span>)</span><br><span class="line">            <span class="title function_">resolveRow</span>(o[k], prefix + k + <span class="string">&quot;.&quot;</span>, row)</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            row[map.<span class="title function_">get</span>(prefix + k)] = o[k]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">o</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> row = <span class="keyword">new</span> <span class="title class_">Array</span>(map.<span class="property">size</span>).<span class="title function_">fill</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="title function_">resolveRow</span>(o, <span class="string">&quot;&quot;</span>, row)</span><br><span class="line">    result.<span class="title function_">push</span>(row)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>完整代码</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Item</span> = (<span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span> | <span class="literal">null</span>)[]</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">jsonToMatrix</span>(<span class="params">arr: <span class="built_in">any</span>[]</span>): <span class="title class_">Item</span>[] &#123;</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">getEveryKey</span>(<span class="params">o: <span class="built_in">object</span>, prefix: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> k <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(o)) &#123;</span><br><span class="line">            <span class="comment">// 如果是可枚举类型则继续递归</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">typeof</span> o[k] === <span class="string">&quot;object&quot;</span> &amp;&amp; o[k] !== <span class="literal">null</span>)</span><br><span class="line">                <span class="title function_">getEveryKey</span>(o[k], prefix + k + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                set.<span class="title function_">add</span>(prefix + k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成所有key</span></span><br><span class="line">    arr.<span class="title function_">forEach</span>(<span class="function"><span class="params">o</span> =&gt;</span> <span class="title function_">getEveryKey</span>(o, <span class="string">&quot;&quot;</span>))</span><br><span class="line">    <span class="comment">// 默认将元素转换为字符串，根据unicode码排序 eg: (b,c,a) =&gt; (a,b,c)</span></span><br><span class="line">    <span class="keyword">const</span> titles = <span class="title class_">Array</span>.<span class="title function_">from</span>(set).<span class="title function_">sort</span>();</span><br><span class="line">    result.<span class="title function_">push</span>(titles);</span><br><span class="line">    <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>&lt;<span class="built_in">string</span>, <span class="built_in">number</span>&gt;();</span><br><span class="line">    titles.<span class="title function_">forEach</span>(<span class="function">(<span class="params">v, i</span>) =&gt;</span> map.<span class="title function_">set</span>(v, i))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">resolveRow</span>(<span class="params">o:<span class="built_in">object</span>, prefix:<span class="built_in">string</span>, row:Item</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> k <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(o)) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">typeof</span> o[k] === <span class="string">&quot;object&quot;</span> &amp;&amp; o[k] !== <span class="literal">null</span>)</span><br><span class="line">                <span class="title function_">resolveRow</span>(o[k], prefix + k + <span class="string">&quot;.&quot;</span>, row);</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                row[map.<span class="title function_">get</span>(prefix + k)] = o[k]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    arr.<span class="title function_">forEach</span>(<span class="function"><span class="params">o</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="attr">row</span>: <span class="title class_">Item</span> = <span class="keyword">new</span> <span class="title class_">Array</span>(map.<span class="property">size</span>).<span class="title function_">fill</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="title function_">resolveRow</span>(o, <span class="string">&quot;&quot;</span>, row);</span><br><span class="line">        result.<span class="title function_">push</span>(row);</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2693-使用自定义上下文调用函数"><a href="#2693-使用自定义上下文调用函数" class="headerlink" title="2693.使用自定义上下文调用函数"></a>2693.使用自定义上下文调用函数</h2><p>增强所有函数，使其具有 <code>callPolyfill</code> 方法。该方法接受一个对象 <code>obj</code> 作为第一个参数，以及任意数量的附加参数。<code>obj</code> 成为函数的 <code>this</code> 上下文。附加参数将传递给该函数（即 <code>callPolyfill</code> 方法所属的函数）。</p>
<p>例如，如果有以下函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function tax(price, taxRate) &#123;</span><br><span class="line">  const totalCost = price * (1 + taxRate);</span><br><span class="line">  console.log(`The cost of $&#123;this.item&#125; is $&#123;totalCost&#125;`);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 <code>tax(10, 0.1)</code> 将输出 <code>&quot;The cost of undefined is 11&quot;</code> 。这是因为 <code>this</code> 上下文未定义。</p>
<p>然而，调用 <code>tax.callPolyfill(&#123;item: &quot;salad&quot;&#125;, 10, 0.1)</code> 将输出 <code>&quot;The cost of salad is 11&quot;</code> 。<code>this</code> 上下文被正确设置，函数输出了适当的结果。</p>
<p>请在不使用内置的 <code>Function.call</code> 方法的情况下解决这个问题。</p>
<blockquote>
<p>实际上就是手写一个function.call()函数</p>
</blockquote>
<h3 id="题解-26"><a href="#题解-26" class="headerlink" title="题解"></a>题解</h3><h4 id="方法一-经典写法"><a href="#方法一-经典写法" class="headerlink" title="方法一 经典写法"></a>方法一 经典写法</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable language_">global</span> &#123; </span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Function</span> &#123;</span><br><span class="line">      <span class="title function_">callPolyfill</span>(<span class="attr">context</span>: <span class="title class_">Record</span>&lt;<span class="built_in">any</span>, <span class="built_in">any</span>&gt;, ...<span class="attr">args</span>: <span class="built_in">any</span>[]): <span class="built_in">any</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">callPolyfill</span> = <span class="keyword">function</span>(<span class="params">context, ...args</span>): <span class="built_in">any</span> &#123;</span><br><span class="line">    context ||= <span class="variable language_">window</span>;</span><br><span class="line">    context.<span class="property">fn</span> = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">const</span> result = context.<span class="title function_">fn</span>(...args);</span><br><span class="line">    <span class="keyword">delete</span> context.<span class="property">fn</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法通不过测试用例<code>function keys() &#123; return Object.keys(this); &#125;</code>。</p>
<h4 id="方法二-使用Symbol来解决Object-keys-this-问题"><a href="#方法二-使用Symbol来解决Object-keys-this-问题" class="headerlink" title="方法二 使用Symbol来解决Object.keys(this)问题"></a>方法二 使用Symbol来解决Object.keys(this)问题</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Object</span>&#125; <span class="variable">context</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">any[]</span>&#125; <span class="variable">args</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">any</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">callPolyfill</span> = <span class="keyword">function</span>(<span class="params">context, ...args</span>) &#123;</span><br><span class="line">  context ||= <span class="variable language_">window</span>;</span><br><span class="line">  <span class="keyword">const</span> key = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="variable language_">this</span>);</span><br><span class="line">  context[key] = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">const</span> result = context[key](...args);</span><br><span class="line">  <span class="keyword">delete</span> context[key];</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在js中，使用 Symbol 作为对象的属性名时，它是一个独一无二的值，不会被遍历或显示出来。因此，当使用 <code>Object.keys()</code> 或 <code>for...in</code> 循环遍历对象属性时，不会包括使用 Symbol 作为属性名的属性。</p>
<p>但是， <strong>TypeScript 不允许使用唯一符号（unique symbol）作为索引类型导致的。</strong></p>
<blockquote>
<p>TypeScript 的类型系统在编译时会执行静态类型检查，以确保代码的类型安全性。由于 <code>symbol</code> 无法被索引，因此在类型检查期间无法准确推断 <code>symbol</code> 作为键名的属性类型。</p>
<p>为了确保类型安全和一致性，TypeScript 限制了使用 <code>symbol</code> 作为键名的能力。这样可以防止在编译时出现潜在的错误，并促使开发者使用其他可索引的键类型，如字符串或数字，来定义对象的属性。</p>
</blockquote>
<h4 id="方法三-使用Object-defineProperty来解决Object-keys-this-问题"><a href="#方法三-使用Object-defineProperty来解决Object-keys-this-问题" class="headerlink" title="方法三 使用Object.defineProperty来解决Object.keys(this)问题"></a>方法三 使用Object.defineProperty来解决Object.keys(this)问题</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable language_">global</span> &#123; </span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Function</span> &#123;</span><br><span class="line">      <span class="title function_">callPolyfill</span>(<span class="attr">context</span>: <span class="title class_">Record</span>&lt;<span class="built_in">any</span>, <span class="built_in">any</span>&gt;, ...<span class="attr">args</span>: <span class="built_in">any</span>[]): <span class="built_in">any</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">callPolyfill</span> = <span class="keyword">function</span>(<span class="params">context, ...args</span>): <span class="built_in">any</span> &#123;</span><br><span class="line">    context ||= <span class="variable language_">window</span>;</span><br><span class="line">    <span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(context, <span class="string">&quot;fn&quot;</span>, &#123;</span><br><span class="line">        <span class="attr">enumerable</span>:<span class="literal">false</span>,</span><br><span class="line">        <span class="attr">writable</span>:<span class="literal">false</span>,</span><br><span class="line">        <span class="attr">value</span>:<span class="variable language_">this</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">const</span> result = context.<span class="title function_">fn</span>(...args);</span><br><span class="line">    <span class="keyword">delete</span> context.<span class="property">fn</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Reflect-defineProperty-和-Object-defineProperty"><a href="#Reflect-defineProperty-和-Object-defineProperty" class="headerlink" title="Reflect.defineProperty 和 Object.defineProperty"></a><code>Reflect.defineProperty</code> 和 <code>Object.defineProperty</code></h4><blockquote>
<p><code>Reflect.defineProperty</code> 和 <code>Object.defineProperty</code> 都是用于定义对象属性的方法，它们具有类似的功能，但在一些细节上有所不同。</p>
<p><code>Object.defineProperty</code> 是 ES5 中引入的方法，而 <code>Reflect.defineProperty</code> 是在 ES6 中添加到 <code>Reflect</code> 对象上的方法。它们的作用是在一个对象上定义一个新的属性或修改现有属性的特性。</p>
<p>下面是它们之间的一些区别：</p>
<ol>
<li>返回值:<ul>
<li><code>Object.defineProperty</code> 返回被操作的对象。</li>
<li><code>Reflect.defineProperty</code> 返回一个布尔值，表示属性是否定义成功。</li>
</ul>
</li>
<li>错误处理：<ul>
<li><code>Object.defineProperty</code> 会抛出异常（TypeError）来表示定义属性时的错误，例如不可配置的属性不允许重新定义等。</li>
<li><code>Reflect.defineProperty</code> 在失败时不会抛出异常，而是返回 <code>false</code>。</li>
</ul>
</li>
<li>参数顺序：<ul>
<li><code>Object.defineProperty</code> 的参数顺序为：<code>Object.defineProperty(obj, prop, descriptor)</code></li>
<li><code>Reflect.defineProperty</code> 的参数顺序为：<code>Reflect.defineProperty(obj, prop, descriptor)</code></li>
</ul>
</li>
</ol>
<p>总体而言，<code>Reflect.defineProperty</code> 提供了一种更统一和一致的方式来定义和操作对象的属性，而且在一些特殊情况下，它比 <code>Object.defineProperty</code> 更加灵活和方便。然而，在大多数情况下，它们的用法和效果是相似的，选择使用哪个方法主要取决于个人偏好和项目需求。</p>
</blockquote>
<h4 id="方法四-使用原型链"><a href="#方法四-使用原型链" class="headerlink" title="方法四 使用原型链"></a>方法四 使用原型链</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 原型链来解决Object.keys(this)问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">callPolyfill</span> = <span class="keyword">function</span> (<span class="params">context, ...args</span>) &#123;</span><br><span class="line">  context ||= <span class="variable language_">window</span>;</span><br><span class="line">  context.<span class="property">__proto__</span>.<span class="property">fn</span> = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">const</span> result = context.<span class="title function_">fn</span>(...args);</span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">__proto__</span>.<span class="property">fn</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="方法五-使用proxy代理"><a href="#方法五-使用proxy代理" class="headerlink" title="方法五 使用proxy代理"></a>方法五 使用proxy代理</h4><p>通过使用 <code>Proxy</code> 对象，创建了一个代理对象 <code>proxy</code>，用于拦截对 <code>context</code> 的属性访问。在访问属性时，如果属性名为 “fn”，则返回保存的函数 <code>fn</code>；否则，使用 <code>Reflect.get</code> 方法来获取实际属性值。</p>
<p>在这个实现中，通过代理对象 <code>proxy</code>，我们在访问属性时拦截了对 <code>context</code> 对象的访问。当访问属性名为 “fn” 时，代理对象返回的是保存的函数 <code>fn</code>；对于其他属性名，则通过 <code>Reflect.get</code> 方法从实际的 <code>context</code> 对象中获取属性值。</p>
<p>实际上，<code>context</code> 对象本身并没有名为 “fn” 的属性。代理对象只是在访问属性时拦截并返回了一个特定的值。这样做的目的是为了模拟函数调用时的行为，让我们可以在指定的上下文中调用函数，并传入相应的参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * proxy代理来解决Object.keys(this)问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">callPolyfill</span> = <span class="keyword">function</span> (<span class="params">context, ...args</span>) &#123;</span><br><span class="line">  context ||= <span class="variable language_">window</span>;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(context, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, prop</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (prop === <span class="string">&quot;fn&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> fn;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> proxy[<span class="string">&quot;fn&quot;</span>](...args);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2696-事件发射器"><a href="#2696-事件发射器" class="headerlink" title="2696.事件发射器"></a>2696.事件发射器</h2><p>设计一个 <code>EventEmitter</code> 类。这个接口与 Node.js 或 DOM 的 Event Target 接口相似，但有一些差异。<code>EventEmitter</code> 应该允许订阅事件和触发事件。</p>
<p>你的 <code>EventEmitter</code> 类应该有以下两个方法：</p>
<ul>
<li><strong>subscribe</strong> - 这个方法接收两个参数：一个作为字符串的事件名和一个回调函数。当事件被触发时，这个回调函数将被调用。 一个事件应该能够有多个监听器。当触发带有多个回调函数的事件时，应按照订阅的顺序依次调用每个回调函数。应返回一个结果数组。你可以假设传递给 <code>subscribe</code> 的回调函数都不是引用相同的。 <code>subscribe</code> 方法还应返回一个对象，其中包含一个 <code>unsubscribe</code> 方法，使用户可以取消订阅。当调用 <code>unsubscribe</code> 方法时，回调函数应该从订阅列表中删除，并返回 undefined。</li>
<li><strong>emit</strong> - 这个方法接收两个参数：一个作为字符串的事件名和一个可选的参数数组，这些参数将传递给回调函数。如果没有订阅给定事件的回调函数，则返回一个空数组。否则，按照它们被订阅的顺序返回所有回调函数调用的结果数组。</li>
</ul>
<h3 id="题解-27"><a href="#题解-27" class="headerlink" title="题解"></a>题解</h3><h4 id="方法一-用map来保存事件和回调函数的映射"><a href="#方法一-用map来保存事件和回调函数的映射" class="headerlink" title="方法一 用map来保存事件和回调函数的映射"></a>方法一 用map来保存事件和回调函数的映射</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Callback</span> = <span class="function">(<span class="params">...args: <span class="built_in">any</span>[]</span>) =&gt;</span> <span class="built_in">any</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Subscription</span> = &#123;</span><br><span class="line">    <span class="attr">unsubscribe</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventEmitter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>&lt;<span class="built_in">string</span>, <span class="title class_">Callback</span>[]&gt;();</span><br><span class="line">  <span class="title function_">subscribe</span>(<span class="attr">eventName</span>: <span class="built_in">string</span>, <span class="attr">callback</span>: <span class="title class_">Callback</span>): <span class="title class_">Subscription</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">has</span>(eventName)) <span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">set</span>(eventName, []);</span><br><span class="line">    <span class="keyword">const</span> callbacks = <span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">get</span>(eventName);</span><br><span class="line">    callbacks.<span class="title function_">push</span>(callback);</span><br><span class="line">    <span class="keyword">const</span> index = callbacks.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">unsubscribe</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          callbacks.<span class="title function_">splice</span>(index, <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">emit</span>(<span class="attr">eventName</span>: <span class="built_in">string</span>, <span class="attr">args</span>: <span class="built_in">any</span>[] = []): <span class="built_in">any</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> callbacks = <span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">get</span>(eventName) || [];</span><br><span class="line">      <span class="keyword">return</span> callbacks.<span class="title function_">map</span>(<span class="function"><span class="params">callback</span> =&gt;</span> <span class="title function_">callback</span>(...args))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * const emitter = new EventEmitter();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * // Subscribe to the onClick event with onClickCallback</span></span><br><span class="line"><span class="comment"> * function onClickCallback() &#123; return 99 &#125;</span></span><br><span class="line"><span class="comment"> * const sub = emitter.subscribe(&#x27;onClick&#x27;, onClickCallback);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * emitter.emit(&#x27;onClick&#x27;); // [99]</span></span><br><span class="line"><span class="comment"> * sub.unsubscribe(); // undefined</span></span><br><span class="line"><span class="comment"> * emitter.emit(&#x27;onClick&#x27;); // []</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h4 id="方法二-用Record"><a href="#方法二-用Record" class="headerlink" title="方法二 用Record"></a>方法二 用Record</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Callback</span> = <span class="function">(<span class="params">...args: <span class="built_in">unknown</span>[]</span>) =&gt;</span> <span class="built_in">unknown</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Subscription</span> = &#123;</span><br><span class="line">  <span class="attr">unsubscribe</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventEmitter</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="attr">_events</span>: <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="title class_">Callback</span>[]&gt; = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">subscribe</span>(<span class="attr">eventName</span>: <span class="built_in">string</span>, <span class="attr">callback</span>: <span class="title class_">Callback</span>): <span class="title class_">Subscription</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">_events</span>[eventName]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_events</span>[eventName] = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_events</span>[eventName].<span class="title function_">push</span>(callback)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">unsubscribe</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_events</span>[eventName] = <span class="variable language_">this</span>.<span class="property">_events</span>[eventName].<span class="title function_">filter</span>(<span class="function"><span class="params">cb</span> =&gt;</span> cb !== callback)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">emit</span>(<span class="attr">eventName</span>: <span class="built_in">string</span>, <span class="attr">args</span>: <span class="built_in">unknown</span>[] = []): <span class="built_in">unknown</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> callbacks = <span class="variable language_">this</span>.<span class="property">_events</span>[eventName] || []</span><br><span class="line">    <span class="keyword">return</span> callbacks.<span class="title function_">map</span>(<span class="function"><span class="params">cb</span> =&gt;</span> <span class="title function_">cb</span>(...args))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2695-包装数组"><a href="#2695-包装数组" class="headerlink" title="2695.包装数组"></a>2695.包装数组</h2><p>创建一个名为 <code>ArrayWrapper</code> 的类，它在其构造函数中接受一个整数数组作为参数。该类应具有以下两个特性：</p>
<ul>
<li>当使用 <code>+</code> 运算符将两个该类的实例相加时，结果值为两个数组中所有元素的总和。</li>
<li>当在实例上调用 <code>String()</code> 函数时，它将返回一个由逗号分隔的括在方括号中的字符串。例如，<code>[1,2,3]</code> 。</li>
</ul>
<h3 id="题解-28"><a href="#题解-28" class="headerlink" title="题解"></a>题解</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayWrapper</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> arr = [];</span><br><span class="line">	<span class="title function_">constructor</span>(<span class="params">nums: <span class="built_in">number</span>[]</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">getElement</span>(nums)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> getElement = <span class="function">(<span class="params">argsNums</span>) =&gt;</span> &#123;</span><br><span class="line">        argsNums.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(item)) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="title function_">getElement</span>(item);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">arr</span>.<span class="title function_">push</span>(item);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="title function_">valueOf</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">arr</span>.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, next</span>) =&gt;</span> prev + next, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// return `[$&#123;this.arr.toString()&#125;]`</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">`[<span class="subst">$&#123;[...<span class="variable language_">this</span>.arr]&#125;</span>]`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * const obj1 = new ArrayWrapper([1,2]);</span></span><br><span class="line"><span class="comment"> * const obj2 = new ArrayWrapper([3,4]);</span></span><br><span class="line"><span class="comment"> * obj1 + obj2; // 10</span></span><br><span class="line"><span class="comment"> * String(obj1); // &quot;[1,2]&quot;</span></span><br><span class="line"><span class="comment"> * String(obj2); // &quot;[3,4]&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="2703-返回传递的参数的长度"><a href="#2703-返回传递的参数的长度" class="headerlink" title="2703.返回传递的参数的长度"></a>2703.返回传递的参数的长度</h2><p>请你编写一个函数 <code>argumentsLength</code>，返回传递给该函数的参数数量。</p>
<h3 id="题解-29"><a href="#题解-29" class="headerlink" title="题解"></a>题解</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">argumentsLength</span>(<span class="params">...args: <span class="built_in">any</span>[]</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> [...args].<span class="property">length</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * argumentsLength(1, 2, 3); // 3</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>arguments</code> 是一个类数组对象，包含函数调用时传递给函数的所有参数。它是一个特殊的对象，在函数内部自动创建并可用于访问所有传入的参数，无需事先定义函数参数。</p>
<p><code>...args</code> 是剩余参数（Rest Parameters）语法，它允许将函数的多个参数收集到一个数组中。它使用三个点（…）作为前缀，后面跟着一个数组名（args）。在函数声明或函数表达式中，它用于指定函数的最后一个参数可以接受多个参数值，并将这些值收集到一个数组中。</p>
<p>主要区别如下：</p>
<ul>
<li><code>arguments</code> 是一个类数组对象，可以在函数内部访问所有传入的参数，包括未在函数签名中声明的参数。它不是一个真正的数组，因此无法使用数组方法和属性。</li>
<li><code>...args</code> 是用于声明函数的剩余参数的语法。它将传递给函数的多个参数收集到一个真正的数组中，可以使用数组方法和属性对其进行操作。</li>
</ul>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">javascriptCopy code<span class="keyword">function</span> <span class="title function_">example</span>(<span class="params">a, b, ...args</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 输出第一个参数</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// 输出第二个参数</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(args); <span class="comment">// 输出剩余的参数数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">example</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// [3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<p>注意：使用剩余参数语法 <code>...args</code> 可以更方便地处理可变数量的参数，而不必依赖于 <code>arguments</code> 对象。此外，<code>arguments</code> 对象在箭头函数中是不可用的，而剩余参数语法可以在箭头函数中使用。</p>
</blockquote>
<h2 id="2704-相等还是不相等"><a href="#2704-相等还是不相等" class="headerlink" title="2704.相等还是不相等"></a>2704.相等还是不相等</h2><p>请你编写一个名为 <code>expect</code> 的函数，用于帮助开发人员测试他们的代码。它应该接受任何值 <code>val</code> 并返回一个包含以下两个函数的对象。</p>
<ul>
<li><code>toBe(val)</code> 接受另一个值并在两个值相等（ <code>===</code> ）时返回 <code>true</code> 。如果它们不相等，则应抛出错误 <code>&quot;Not Equal&quot;</code> 。</li>
<li><code>notToBe(val)</code> 接受另一个值并在两个值不相等（ <code>!==</code> ）时返回 <code>true</code> 。如果它们相等，则应抛出错误 <code>&quot;Equal&quot;</code> 。</li>
</ul>
<h3 id="题解-30"><a href="#题解-30" class="headerlink" title="题解"></a>题解</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ToBeOrNotToBe</span> = &#123;</span><br><span class="line">    <span class="attr">toBe</span>: <span class="function">(<span class="params">val: <span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="attr">notToBe</span>: <span class="function">(<span class="params">val: <span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">boolean</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">expect</span>(<span class="params">val: <span class="built_in">any</span></span>): <span class="title class_">ToBeOrNotToBe</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">toBe</span>: <span class="function">(<span class="params">matchVal: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(val === matchVal) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Not Equal&quot;</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">notToBe</span>:<span class="function">(<span class="params">matchVal: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(val !== matchVal) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Equal&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * expect(5).toBe(5); // true</span></span><br><span class="line"><span class="comment"> * expect(5).notToBe(5); // throws &quot;Equal&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="2705-精简对象"><a href="#2705-精简对象" class="headerlink" title="2705.精简对象"></a>2705.精简对象</h2><p>现给定一个对象或数组 <code>obj</code>，返回一个 <strong>精简对象</strong> 。<strong>精简对象</strong> 与原始对象相同，只是将包含 <strong>假</strong> 值的键移除。该操作适用于对象及其嵌套对象。数组被视为索引作为键的对象。当 <code>Boolean(value)</code> 返回 <code>false</code> 时，值被视为 <strong>假</strong> 值。</p>
<p>你可以假设 <code>obj</code> 是 <code>JSON.parse</code> 的输出结果。换句话说，它是有效的 JSON。</p>
<h3 id="题解-31"><a href="#题解-31" class="headerlink" title="题解"></a>题解</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Obj</span> = <span class="title class_">Record</span>&lt;<span class="built_in">any</span>, <span class="built_in">any</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">compactObject</span>(<span class="params">obj: Obj</span>): <span class="title class_">Obj</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(obj === <span class="literal">null</span> || <span class="keyword">typeof</span> obj !== <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj)) &#123;</span><br><span class="line">        <span class="keyword">const</span> res = [];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> obj) &#123;</span><br><span class="line">            <span class="keyword">const</span> val = <span class="title function_">compactObject</span>(item);</span><br><span class="line">            <span class="keyword">if</span>(val) res.<span class="title function_">push</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> res = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)) &#123;</span><br><span class="line">        <span class="keyword">const</span> o = <span class="title function_">compactObject</span>(obj[key]);</span><br><span class="line">        <span class="keyword">if</span>(o) res[key] = o; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%89%8B%E5%86%99%E9%A2%98/" rel="tag"># 手写题</a>
              <a href="/tags/js/" rel="tag"># js</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/04/26/open-tiny%E5%85%A5%E9%97%A8/" rel="prev" title="opentiny入门">
      <i class="fa fa-chevron-left"></i> opentiny入门
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#2618-%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E6%98%AF%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B"><span class="nav-number">1.</span> <span class="nav-text">2618.检查是否是类的对象实例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3"><span class="nav-number">1.1.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2619-%E6%95%B0%E7%BB%84%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="nav-number">2.</span> <span class="nav-text">2619.数组原型对象的最后一个元素</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-1"><span class="nav-number">2.1.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2620-%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="nav-number">3.</span> <span class="nav-text">2620.计数器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-2"><span class="nav-number">3.1.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2621-%E7%9D%A1%E7%9C%A0%E5%87%BD%E6%95%B0"><span class="nav-number">4.</span> <span class="nav-text">2621.睡眠函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-3"><span class="nav-number">4.1.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2622-%E6%9C%89%E6%97%B6%E9%97%B4%E9%99%90%E5%88%B6%E7%9A%84%E7%BC%93%E5%AD%98"><span class="nav-number">5.</span> <span class="nav-text">2622.有时间限制的缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-4"><span class="nav-number">5.1.</span> <span class="nav-text">题解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95%E4%B8%80"><span class="nav-number">5.1.1.</span> <span class="nav-text">解法一</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95%E4%BA%8C"><span class="nav-number">5.1.2.</span> <span class="nav-text">解法二</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95%E4%B8%89"><span class="nav-number">5.1.3.</span> <span class="nav-text">解法三</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2623-%E8%AE%B0%E5%BF%86%E5%87%BD%E6%95%B0"><span class="nav-number">6.</span> <span class="nav-text">2623.记忆函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-5"><span class="nav-number">6.1.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F"><span class="nav-number">6.2.</span> <span class="nav-text">注意</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2624-%E8%9C%97%E7%89%9B%E6%8E%92%E5%BA%8F"><span class="nav-number">7.</span> <span class="nav-text">2624.蜗牛排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-6"><span class="nav-number">7.1.</span> <span class="nav-text">题解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95%E4%B8%80-1"><span class="nav-number">7.1.1.</span> <span class="nav-text">解法一</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E6%B3%95%E4%BA%8C-1"><span class="nav-number">7.1.2.</span> <span class="nav-text">解法二</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%99%E5%AE%9Arow-col%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA%E7%A9%BA%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95-Array-from-Array-fill-Array-map"><span class="nav-number">7.2.</span> <span class="nav-text">给定row col生成一个空数组的方法(Array.from()  Array.fill()  Array.map())</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2625-%E6%89%81%E5%B9%B3%E5%8C%96%E5%B5%8C%E5%A5%97%E6%95%B0%E7%BB%84"><span class="nav-number">8.</span> <span class="nav-text">2625.扁平化嵌套数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-7"><span class="nav-number">8.1.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F-1"><span class="nav-number">8.2.</span> <span class="nav-text">注意</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2626-%E6%95%B0%E7%BB%84%E5%BD%92%E7%BA%A6%E8%BF%90%E7%AE%97"><span class="nav-number">9.</span> <span class="nav-text">2626.数组归约运算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-8"><span class="nav-number">9.1.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2627-%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96"><span class="nav-number">10.</span> <span class="nav-text">2627.函数防抖</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-9"><span class="nav-number">10.1.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2628-%E5%AE%8C%E5%85%A8%E7%9B%B8%E7%AD%89%E7%9A%84-JSON-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">11.</span> <span class="nav-text">2628.完全相等的 JSON 字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-10"><span class="nav-number">11.1.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-entries%EF%BC%88%EF%BC%89"><span class="nav-number">11.2.</span> <span class="nav-text">Object.entries（）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2629-%E5%A4%8D%E5%90%88%E5%87%BD%E6%95%B0"><span class="nav-number">12.</span> <span class="nav-text">2629.复合函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-11"><span class="nav-number">12.1.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#reduceRight"><span class="nav-number">12.2.</span> <span class="nav-text">reduceRight()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2630-%E8%AE%B0%E5%BF%86%E5%87%BD%E6%95%B0%EF%BC%88%E4%BA%8C%EF%BC%89"><span class="nav-number">13.</span> <span class="nav-text">2630.记忆函数（二）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8E%EF%BC%88%E4%B8%80%EF%BC%89%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">13.1.</span> <span class="nav-text">与（一）的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-12"><span class="nav-number">13.2.</span> <span class="nav-text">题解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80-%E5%8F%8CMap"><span class="nav-number">13.2.1.</span> <span class="nav-text">方法一 双Map</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C-%E5%89%8D%E7%BC%80%E5%AD%97%E5%85%B8%E6%A0%91"><span class="nav-number">13.2.2.</span> <span class="nav-text">方法二 前缀字典树</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2631-%E5%88%86%E7%BB%84%E5%87%BD%E6%95%B0"><span class="nav-number">14.</span> <span class="nav-text">2631.分组函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-13"><span class="nav-number">14.1.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2632-%E6%9F%AF%E9%87%8C%E5%8C%96"><span class="nav-number">15.</span> <span class="nav-text">2632.柯里化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-14"><span class="nav-number">15.1.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2633-%E5%B0%86%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%8D%A2%E4%B8%BAJSON%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">16.</span> <span class="nav-text">2633.将对象转换为JSON字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-15"><span class="nav-number">16.1.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2634-%E8%BF%87%E6%BB%A4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0"><span class="nav-number">17.</span> <span class="nav-text">2634.过滤数组中的元素</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-16"><span class="nav-number">17.1.</span> <span class="nav-text">题解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#foreach"><span class="nav-number">17.1.1.</span> <span class="nav-text">foreach</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#reduce"><span class="nav-number">17.1.2.</span> <span class="nav-text">reduce</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2635-%E8%BD%AC%E6%8D%A2%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%AF%8F%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="nav-number">18.</span> <span class="nav-text">2635.转换数组中的每个元素</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-17"><span class="nav-number">18.1.</span> <span class="nav-text">题解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#for"><span class="nav-number">18.1.1.</span> <span class="nav-text">for</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#reduce-1"><span class="nav-number">18.1.2.</span> <span class="nav-text">reduce</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#from"><span class="nav-number">18.1.3.</span> <span class="nav-text">from</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2636-Promise%E5%AF%B9%E8%B1%A1%E6%B1%A0"><span class="nav-number">19.</span> <span class="nav-text">2636.Promise对象池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-18"><span class="nav-number">19.1.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2637-%E6%9C%89%E6%97%B6%E9%97%B4%E9%99%90%E5%88%B6%E7%9A%84Promise%E5%AF%B9%E8%B1%A1"><span class="nav-number">20.</span> <span class="nav-text">2637.有时间限制的Promise对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-19"><span class="nav-number">20.1.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2648-%E7%94%9F%E6%88%90%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="nav-number">21.</span> <span class="nav-text">2648.生成斐波那契数列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-20"><span class="nav-number">21.1.</span> <span class="nav-text">题解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">21.1.1.</span> <span class="nav-text">动态规划</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2649-%E5%B5%8C%E5%A5%97%E6%95%B0%E7%BB%84%E7%94%9F%E6%88%90%E5%99%A8"><span class="nav-number">22.</span> <span class="nav-text">2649.嵌套数组生成器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-21"><span class="nav-number">22.1.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2650-%E8%AE%BE%E8%AE%A1%E5%8F%AF%E5%8F%96%E6%B6%88%E7%9A%84%E5%87%BD%E6%95%B0-hard"><span class="nav-number">23.</span> <span class="nav-text">2650.设计可取消的函数(hard)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-22"><span class="nav-number">23.1.</span> <span class="nav-text">题解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF-generator-%EF%BC%9F%EF%BC%9A"><span class="nav-number">23.1.1.</span> <span class="nav-text">1.什么是 generator ？：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%80%8E%E4%B9%88%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA-generator-%EF%BC%9A"><span class="nav-number">23.1.2.</span> <span class="nav-text">2.怎么定义一个 generator ：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-generator-%E7%9A%84%E5%AE%9E%E4%BE%8B%EF%BC%8C%E6%88%96%E8%80%85%E8%AF%B4%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="nav-number">23.1.3.</span> <span class="nav-text">3.generator 的实例，或者说返回值，有哪些方法？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%9B%9E%E5%88%B0%E6%9C%AC%E9%A2%98"><span class="nav-number">23.1.4.</span> <span class="nav-text">4.回到本题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2665-%E8%AE%A1%E6%95%B0%E5%99%A8II"><span class="nav-number">24.</span> <span class="nav-text">2665.计数器II</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-23"><span class="nav-number">24.1.</span> <span class="nav-text">题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F-2"><span class="nav-number">24.2.</span> <span class="nav-text">注意</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2666-%E5%8F%AA%E5%85%81%E8%AE%B8%E4%B8%80%E6%AC%A1%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="nav-number">25.</span> <span class="nav-text">2666.只允许一次函数调用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-24"><span class="nav-number">25.1.</span> <span class="nav-text">题解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AD%E5%8C%85"><span class="nav-number">25.1.1.</span> <span class="nav-text">闭包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#try%E2%80%A6catch"><span class="nav-number">25.1.2.</span> <span class="nav-text">try…catch</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F-3"><span class="nav-number">25.2.</span> <span class="nav-text">注意</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2675-%E5%B0%86%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%9F%A9%E9%98%B5"><span class="nav-number">26.</span> <span class="nav-text">2675.将对象数组转换为矩阵</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-25"><span class="nav-number">26.1.</span> <span class="nav-text">题解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="nav-number">26.1.1.</span> <span class="nav-text">前置知识</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="nav-number">26.1.2.</span> <span class="nav-text">解题思路</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2693-%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%8A%E4%B8%8B%E6%96%87%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0"><span class="nav-number">27.</span> <span class="nav-text">2693.使用自定义上下文调用函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-26"><span class="nav-number">27.1.</span> <span class="nav-text">题解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80-%E7%BB%8F%E5%85%B8%E5%86%99%E6%B3%95"><span class="nav-number">27.1.1.</span> <span class="nav-text">方法一 经典写法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C-%E4%BD%BF%E7%94%A8Symbol%E6%9D%A5%E8%A7%A3%E5%86%B3Object-keys-this-%E9%97%AE%E9%A2%98"><span class="nav-number">27.1.2.</span> <span class="nav-text">方法二 使用Symbol来解决Object.keys(this)问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%89-%E4%BD%BF%E7%94%A8Object-defineProperty%E6%9D%A5%E8%A7%A3%E5%86%B3Object-keys-this-%E9%97%AE%E9%A2%98"><span class="nav-number">27.1.3.</span> <span class="nav-text">方法三 使用Object.defineProperty来解决Object.keys(this)问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Reflect-defineProperty-%E5%92%8C-Object-defineProperty"><span class="nav-number">27.1.4.</span> <span class="nav-text">Reflect.defineProperty 和 Object.defineProperty</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%9B%9B-%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="nav-number">27.1.5.</span> <span class="nav-text">方法四 使用原型链</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%94-%E4%BD%BF%E7%94%A8proxy%E4%BB%A3%E7%90%86"><span class="nav-number">27.1.6.</span> <span class="nav-text">方法五 使用proxy代理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2696-%E4%BA%8B%E4%BB%B6%E5%8F%91%E5%B0%84%E5%99%A8"><span class="nav-number">28.</span> <span class="nav-text">2696.事件发射器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-27"><span class="nav-number">28.1.</span> <span class="nav-text">题解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80-%E7%94%A8map%E6%9D%A5%E4%BF%9D%E5%AD%98%E4%BA%8B%E4%BB%B6%E5%92%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E6%98%A0%E5%B0%84"><span class="nav-number">28.1.1.</span> <span class="nav-text">方法一 用map来保存事件和回调函数的映射</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C-%E7%94%A8Record"><span class="nav-number">28.1.2.</span> <span class="nav-text">方法二 用Record</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2695-%E5%8C%85%E8%A3%85%E6%95%B0%E7%BB%84"><span class="nav-number">29.</span> <span class="nav-text">2695.包装数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-28"><span class="nav-number">29.1.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2703-%E8%BF%94%E5%9B%9E%E4%BC%A0%E9%80%92%E7%9A%84%E5%8F%82%E6%95%B0%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="nav-number">30.</span> <span class="nav-text">2703.返回传递的参数的长度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-29"><span class="nav-number">30.1.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2704-%E7%9B%B8%E7%AD%89%E8%BF%98%E6%98%AF%E4%B8%8D%E7%9B%B8%E7%AD%89"><span class="nav-number">31.</span> <span class="nav-text">2704.相等还是不相等</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-30"><span class="nav-number">31.1.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2705-%E7%B2%BE%E7%AE%80%E5%AF%B9%E8%B1%A1"><span class="nav-number">32.</span> <span class="nav-text">2705.精简对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%98%E8%A7%A3-31"><span class="nav-number">32.1.</span> <span class="nav-text">题解</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">z</p>
  <div class="site-description" itemprop="description">记录前端学习内容</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">z</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">26k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">1:34</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="true"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  

    </div>
</body>
</html>
